// Author: MyName
// Copyright:   Copyright 2017 Keysight Technologies
//              You have a royalty-free right to use, modify, reproduce and distribute
//              the sample application files (and/or any modified version) in any way
//              you find useful, provided that you agree that Keysight Technologies has no
//              warranty, obligations or liability for any sample application files.
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ComponentModel;
using System.Text.RegularExpressions;

using Keysight.Tap;  // Use Platform infrastructure/core components (log,TestStep definition, etc)
using PcapDotNet.Base;
using PcapDotNet.Core;
using PcapDotNet.Core.Extensions;
using PcapDotNet.Packets;
using PcapDotNet.Packets.Arp;
using PcapDotNet.Packets.Dns;
using PcapDotNet.Packets.Ethernet;
using PcapDotNet.Packets.Gre;
using PcapDotNet.Packets.Http;
using PcapDotNet.Packets.Icmp;
using PcapDotNet.Packets.Igmp;
using PcapDotNet.Packets.IpV4;
using PcapDotNet.Packets.IpV6;
using PcapDotNet.Packets.Transport;
using System.Threading;

namespace Tap.Plugins.Anatel_IPv6_Test
{
    [Display("V6LC Base", Group: "Anatel_IPv6_Test", Description: "Insert description here")]
    public class V6LC_BaseTest : TestStep
    {
        public TraceBar limitBar = new TraceBar { ShowResult = true };
        public UInt32 uintIdentifier = 1;
        public UInt32 uintSequenceNumber = 0;

        [Browsable(false)]
        public bool showValidateEchoRequest { get; set; }
        [Browsable(false)]
        public bool showValidateEchoReply { get; set; }

        #region Settings
        [Display("UXM")]
        public E7515A Uxm { get; set; }

        [EnabledIf("showValidateEchoRequest", true, HideIfDisabled = true)]
        [Display("Validate Echo Request", Group: "Limits", Order: 4.1, Description: "Validate Echo Request")]
        public YesNo validateEchoRequest { get; set; }

        [EnabledIf("showValidateEchoReply", true, HideIfDisabled = true)]
        [Display("Validate Echo Reply", Group: "Limits", Order: 4.2, Description: "Validate Echo Reply")]
        public YesNo validateEchoReply { get; set; }

        #endregion

            protected AnatelSettings anatelSettings = AnatelSettings.Current;
        protected int nicId;
        protected string sourceMAC;
        protected string sourceIPv6Address;
        protected string destinationMAC;
        protected string dutIPv6Address;
        protected YesNo activateDeactivateRouter;

        public V6LC_BaseTest()
        {
            //string MACpattern = @"^(?:[0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}|(?:[0-9a-fA-F]{2}-){5}[0-9a-fA-F]{2}|(?:[0-9a-fA-F]{2}){5}[0-9a-fA-F]{2}$";
            //this.Rules.Add(() => sourceMAC.Length == 17 && Regex.IsMatch(sourceMAC, MACpattern), "Range: 12 digit hexadecimal value", "sourceMAC");
            //this.Rules.Add(() => destinationMAC.Length == 17 && Regex.IsMatch(destinationMAC, MACpattern), "Range: 12 digit hexadecimal value", "destinationMAC");
            //string IPv6pattern = @"(?:^|(?<=\s))(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))(?=\s|$)";
            //// /^(?>(?>([a-f0-9]{1,4})(?>:(?1)){7}|(?!(?:.*[a-f0-9](?>:|$)){8,})((?1)(?>:(?1)){0,6})?::(?2)?)|(?>(?>(?1)(?>:(?1)){5}:|(?!(?:.*[a-f0-9]:){6,})(?3)?::(?>((?1)(?>:(?1)){0,4}):)?)?(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])(?>\.(?4)){3}))$/iD
            //this.Rules.Add(() => Regex.IsMatch(sourceIPv6Address, IPv6pattern), "Range: 32 digit hexadecimal value", "sourceIPv6Address");
            //this.Rules.Add(() => Regex.IsMatch(dutIPv6Address, IPv6pattern), "Range: 32 digit hexadecimal value", "dutIPv6Address");

            //sourceMAC = "00:05:1b:a6:a1:22";
            //destinationMAC = "02:00:55:34:02:43";
            //sourceIPv6Address = "2001:0:5534:243:3867:41f:7f2a:e625";
            //dutIPv6Address = "2001:5:5604:0347:0000:0000:0000:5";

            //nicId = 3;
        }

        public override void PrePlanRun()
        {
            base.PrePlanRun();

            nicId = anatelSettings.nicId;
            sourceMAC = anatelSettings.sourceMAC;
            sourceIPv6Address = anatelSettings.sourceIPv6Address;
            destinationMAC = anatelSettings.destinationMAC;
            dutIPv6Address = anatelSettings.dutIPv6Address;
            activateDeactivateRouter = anatelSettings.activateDeactivateRouter;
        }

        public void CommonTestInit(bool ForceActivate = false)
        {
            sourceMAC = anatelSettings.sourceMAC;
            sourceIPv6Address = anatelSettings.sourceIPv6Address;
            destinationMAC = anatelSettings.destinationMAC;
            dutIPv6Address = anatelSettings.dutIPv6Address;

            if ((activateDeactivateRouter == YesNo.Yes) || (ForceActivate == true))
            {
                // Activate Router state
                Uxm.SetIPv6RouterState(States.ON);
                Uxm.WaitForOperationComplete();
            }
        }

        public void CommonTestCleanup(PacketCommunicator communicator, PcapCapturePackets packetCapture, bool StopCapture = true, bool ActivateDeactivateRouter = true)
        {
            uintSequenceNumber++;
            byte bVer = (byte)Byte.Parse("6");
            byte bTrafficClass = 0;
            int nFlowLabel = 0;


            // Step 1 - TR Transmits a RA with Router Lifetime, Prefix Lifetime, set to zero
            // UXM does this when turning off Router
            // Deactivate Router state
            if (ActivateDeactivateRouter == true)
            {
                if (activateDeactivateRouter == YesNo.Yes)
                {
                    Uxm.SetIPv6RouterState(States.OFF);
                    Uxm.WaitForOperationComplete();
                }
            }

            // Step 2 - Not apply

            // Step 3 - Each TR or TN transmits an echo request and waits for echo reply
            packetCapture.PacketCounter = 0;
            packetCapture.LastPacket = null;
            packetCapture.LastPacketParameterProblem = null;
            packetCapture.EnableDump(false);
            // Make sure the disable dump has taken place
            Thread.Sleep(250);

            Packet packetCleanup = NewBuildIpV6Packet(uintIdentifier, uintSequenceNumber, bVer, bTrafficClass, nFlowLabel, "abcdefghijklmnopqrstuvwabcdefghi", IpV4Protocol.InternetControlMessageProtocolForIpV6);
            communicator.SendPacket(packetCleanup);

            // Wait
            Log.Info("Run()->Sleep");
            int nRetry = 0;
            do
            {
                // Wait until we have received echo and reply
                Thread.Sleep(100);
            } while ((packetCapture.PacketCounter < 2) && (nRetry++ < 40));

            // Validate Received echo
            Console.WriteLine("Packets Received: " + packetCapture.PacketCounter);

            // Stop Packet Capture
            if (StopCapture)
            {
                packetCapture.StopPacketCapture();
                packetCapture = null;
            }

            // Step 4 - Not apply

        }

        protected void UpdateMacAndIPAddress(PacketDevice device, Boolean updateValues)
        {
            if (anatelSettings.sourceMAC.IsNullOrEmpty() || anatelSettings.sourceIPv6Address.IsNullOrEmpty() || updateValues)
            {
                Log.Info("MAC Address or IPv6 Address is empty, proceed to obtain data from interface");
            }
            else
            {
                // We have valid MAC address and IPv6 Address, no need to obtain them
                return;
            }

            // Allow Router to update IPv6 address
            //Thread.Sleep(5000);

            LivePacketDevice liveDevice = (LivePacketDevice)device;
            // Get MAC Address
            MacAddress deviceMacAddress = LivePacketDeviceExtensions.GetMacAddress(liveDevice);
            Log.Info("MAC Address: " + deviceMacAddress);
            anatelSettings.sourceMAC = deviceMacAddress.ToString();

            // GET IPv6
            foreach (DeviceAddress address in liveDevice.Addresses)
            {
                if (address.Address.ToString().StartsWith("Internet6 2001:0000:"))
                {
                    Log.Info("Updating Anatel Settings.sourceIPv6Address: " + anatelSettings.sourceIPv6Address);
                    // Store IPv6 Address
                    IpV6SocketAddress ipv6Address = (IpV6SocketAddress)address.Address;
                    anatelSettings.sourceIPv6Address = ipv6Address.Address.ToString();
                    Log.Info("Updating Anatel Settings.sourceIPv6Address with new value: " + ipv6Address.Address.ToString());
                    break;
                }
                else
                {
                    // ignore link-local address
                    continue;
                }
            }
        }

        public override void Run()
        {
        }

        public override void PostPlanRun()
        {
            base.PostPlanRun();
        }

        /// <summary>
        /// This function build an IPv6 over Ethernet with payload packet.
        /// </summary>
        protected Packet NewBuildIpV6Packet(UInt32 uiIdentifier, UInt32 uiSequence, byte bVersion, byte bTrafficClass, int nFlowLabel, String strPayload, IpV4Protocol nextHeader)
        {
            EthernetLayer ethernetLayer =
                new EthernetLayer
                {
                    Source = new MacAddress(sourceMAC), //"00:05:1b:a6:a1:22"),
                    //Destination = new MacAddress("02:00:55:34:03:08"),    // Joe's UXM
                    Destination = new MacAddress(destinationMAC),   //"02:00:55:34:02:43"),      // Tracy's UXM
                    EtherType = EthernetType.IpV6,
                };

            // 4, 0, 5, 7, and 15
            // 0011, 0000, 0101, 0111, 1111
            IpV6Layer ipV6Layer =
                new IpV6Layer
                {
                    //Source = new IpV6Address("2601:245:4002:30a0:0cfd:a476:6039:1cdc"),
                    //Source = new IpV6Address("2001:0:5534:308:c94a:34d0:92da:39eb"),  // IPv6 assigned to Laptop from Joe's UXM router
                    Source = new IpV6Address(sourceIPv6Address),    //"2001:0:5534:243:3867:41f:7f2a:e625"),    // IPV6 assigned to Laptop from Tracy's UXM router
                    //CurrentDestination = new IpV6Address("2001:5:5534:308:0000:0000:0000:5"),   // DUT's IPV6 assigned from UXM
                    CurrentDestination = new IpV6Address(dutIPv6Address),    //"2001:5:5604:0347:0000:0000:0000:5"),   // DUT's IPV6 assigned from UXM
                    FlowLabel = nFlowLabel,
                    HopLimit = 128,
                    NextHeader = nextHeader,    
                    CustomVersion = bVersion,
                    TrafficClass = bTrafficClass,
                };

            //ipV6Layer.CustomVersion = 0x04;
            uint uintLayerVariable;
            uintLayerVariable = (uiIdentifier << 16) | uiSequence;


            IcmpIpv6UnknownLayer icmpIpv6Layer = new IcmpIpv6UnknownLayer();
            icmpIpv6Layer.LayerMessageType = 0x80;
            icmpIpv6Layer.LayerCode = 0;
            //icmpIpv6Layer.LayerVariable = 0x0001F001;   // Identifier + Sequence = 00 01 00 84 
            icmpIpv6Layer.LayerVariable = uintLayerVariable;
            icmpIpv6Layer.Payload = new Datagram(Encoding.ASCII.GetBytes(strPayload));
            Console.WriteLine("Checksum: " + icmpIpv6Layer.Checksum);

            PacketBuilder builder = new PacketBuilder(ethernetLayer, ipV6Layer, icmpIpv6Layer);
            Console.WriteLine("Checksum: " + icmpIpv6Layer.Checksum);

            Packet newPacket = builder.Build(DateTime.Now);

            return newPacket;
        }

        /// <summary>
        /// This function build an IPv6 over Ethernet with payload packet.
        /// </summary>
        protected Packet NewBuildIpV6PacketGroup2NextHeaderZero(UInt32 uiIdentifier, UInt32 uiSequence, byte bVersion, byte bTrafficClass, int nFlowLabel, String strPayload, IpV4Protocol nextHeader)
        {
            EthernetLayer ethernetLayer =
                new EthernetLayer
                {
                    Source = new MacAddress(sourceMAC), //"00:05:1b:a6:a1:22"),
                    //Destination = new MacAddress("02:00:55:34:03:08"),    // Joe's UXM
                    Destination = new MacAddress(destinationMAC),   //"02:00:55:34:02:43"),      // Tracy's UXM
                    EtherType = EthernetType.IpV6,
                };

            // 4, 0, 5, 7, and 15
            // 0011, 0000, 0101, 0111, 1111
            IpV6Layer ipV6Layer =
                new IpV6Layer
                {
                    //Source = new IpV6Address("2601:245:4002:30a0:0cfd:a476:6039:1cdc"),
                    //Source = new IpV6Address("2001:0:5534:308:c94a:34d0:92da:39eb"),  // IPv6 assigned to Laptop from Joe's UXM router
                    Source = new IpV6Address(sourceIPv6Address),    //"2001:0:5534:243:3867:41f:7f2a:e625"),    // IPV6 assigned to Laptop from Tracy's UXM router
                    //CurrentDestination = new IpV6Address("2001:5:5534:308:0000:0000:0000:5"),   // DUT's IPV6 assigned from UXM
                    CurrentDestination = new IpV6Address(dutIPv6Address),    //"2001:5:5604:0347:0000:0000:0000:5"),   // DUT's IPV6 assigned from UXM
                    FlowLabel = nFlowLabel,
                    HopLimit = 128,
                    NextHeader = nextHeader,    //IpV4Protocol.IpV6HopByHopOption,
                    CustomVersion = bVersion,
                    TrafficClass = bTrafficClass,
                };

            IpV6OptionPadN optpadN = new IpV6OptionPadN(4);

            IpV6Options ipv6options = new IpV6Options(optpadN);

            IpV6ExtensionHeaderHopByHopOptions ipv6ExtensionHeader =
                new IpV6ExtensionHeaderHopByHopOptions(IpV4Protocol.IpV6HopByHopOption, ipv6options);
            IpV6ExtensionHeaderHopByHopOptions ipv6ExtensionHeader2 =
                new IpV6ExtensionHeaderHopByHopOptions(IpV4Protocol.InternetControlMessageProtocolForIpV6, ipv6options);

            // Test Case
            IpV6ExtensionHeaders ipv6ExtHeads = new IpV6ExtensionHeaders(ipv6ExtensionHeader, ipv6ExtensionHeader2);

            // Testing proper use of formed command
            //IpV6ExtensionHeaders ipv6ExtHeads = new IpV6ExtensionHeaders(ipv6ExtensionHeader2);

            ipV6Layer.ExtensionHeaders = ipv6ExtHeads;




            //ipV6Layer.CustomVersion = 0x04;
            uint uintLayerVariable;
            uintLayerVariable = (uiIdentifier << 16) | uiSequence;


            IcmpIpv6UnknownLayer icmpIpv6Layer = new IcmpIpv6UnknownLayer();
            icmpIpv6Layer.LayerMessageType = 0x80;
            icmpIpv6Layer.LayerCode = 0;
            //icmpIpv6Layer.LayerVariable = 0x0001F001;   // Identifier + Sequence = 00 01 00 84 
            icmpIpv6Layer.LayerVariable = uintLayerVariable;
            icmpIpv6Layer.Payload = new Datagram(Encoding.ASCII.GetBytes(strPayload));
            Console.WriteLine("Checksum: " + icmpIpv6Layer.Checksum);
            Log.Info("Checksum: " + icmpIpv6Layer.Checksum);

            PacketBuilder builder = new PacketBuilder(ethernetLayer, ipV6Layer, icmpIpv6Layer);
            Console.WriteLine("Checksum: " + icmpIpv6Layer.Checksum);
            Log.Info("Checksum: " + icmpIpv6Layer.Checksum);

            Packet newPacket = builder.Build(DateTime.Now);

            return newPacket;
        }


        /// <summary>
        /// This function build an IPv6 over Ethernet with payload packet.
        /// </summary>
        protected Packet NewBuildIpV6PacketGroup2NoNextHeader(UInt32 uiIdentifier, UInt32 uiSequence, byte bVersion, byte bTrafficClass, int nFlowLabel, String strPayload, IpV4Protocol nextHeader)
        {
            EthernetLayer ethernetLayer =
                new EthernetLayer
                {
                    Source = new MacAddress(sourceMAC), //"00:05:1b:a6:a1:22"),
                    //Destination = new MacAddress("02:00:55:34:03:08"),    // Joe's UXM
                    Destination = new MacAddress(destinationMAC),   //"02:00:55:34:02:43"),      // Tracy's UXM
                    EtherType = EthernetType.IpV6,
                };

            // 4, 0, 5, 7, and 15
            // 0011, 0000, 0101, 0111, 1111
            IpV6Layer ipV6Layer =
                new IpV6Layer
                {
                    //Source = new IpV6Address("2601:245:4002:30a0:0cfd:a476:6039:1cdc"),
                    //Source = new IpV6Address("2001:0:5534:308:c94a:34d0:92da:39eb"),  // IPv6 assigned to Laptop from Joe's UXM router
                    Source = new IpV6Address(sourceIPv6Address),    //"2001:0:5534:243:3867:41f:7f2a:e625"),    // IPV6 assigned to Laptop from Tracy's UXM router
                    //CurrentDestination = new IpV6Address("2001:5:5534:308:0000:0000:0000:5"),   // DUT's IPV6 assigned from UXM
                    CurrentDestination = new IpV6Address(dutIPv6Address),    //"2001:5:5604:0347:0000:0000:0000:5"),   // DUT's IPV6 assigned from UXM
                    FlowLabel = nFlowLabel,
                    HopLimit = 128,
                    NextHeader = nextHeader,    //IpV4Protocol.IpV6Opts,
                    CustomVersion = bVersion,
                    TrafficClass = bTrafficClass,
                };

            IpV6OptionPadN optpadN = new IpV6OptionPadN(4);

            IpV6Options ipv6options = new IpV6Options(optpadN);

            IpV6ExtensionHeaderHopByHopOptions ipv6ExtensionHeader =
                new IpV6ExtensionHeaderHopByHopOptions(IpV4Protocol.NoNextHeaderForIpV6, ipv6options);

            // Test Case
            IpV6ExtensionHeaders ipv6ExtHeads = new IpV6ExtensionHeaders(ipv6ExtensionHeader);

            ipV6Layer.ExtensionHeaders = ipv6ExtHeads;




            //ipV6Layer.CustomVersion = 0x04;
            uint uintLayerVariable;
            uintLayerVariable = (uiIdentifier << 16) | uiSequence;


            IcmpIpv6UnknownLayer icmpIpv6Layer = new IcmpIpv6UnknownLayer();
            icmpIpv6Layer.LayerMessageType = 0x80;
            icmpIpv6Layer.LayerCode = 0;
            //icmpIpv6Layer.LayerVariable = 0x0001F001;   // Identifier + Sequence = 00 01 00 84 
            icmpIpv6Layer.LayerVariable = uintLayerVariable;
            icmpIpv6Layer.Payload = new Datagram(Encoding.ASCII.GetBytes(strPayload));
            Console.WriteLine("Checksum: " + icmpIpv6Layer.Checksum);
            Log.Info("Checksum: " + icmpIpv6Layer.Checksum);

            PacketBuilder builder = new PacketBuilder(ethernetLayer, ipV6Layer, icmpIpv6Layer);
            Console.WriteLine("Checksum: " + icmpIpv6Layer.Checksum);
            Log.Info("Checksum: " + icmpIpv6Layer.Checksum);

            Packet newPacket = builder.Build(DateTime.Now);

            return newPacket;
        }

        /// <summary>
        /// This function build an IPv6 over Ethernet with payload packet.
        /// </summary>
        protected Packet NewBuildIpV6PacketGroup2UnrecognizedNextHeaderPacketA(UInt32 uiIdentifier, UInt32 uiSequence, byte bVersion, byte bTrafficClass, int nFlowLabel, String strPayload, IpV4Protocol nextHeader)
        {
            EthernetLayer ethernetLayer =
                new EthernetLayer
                {
                    Source = new MacAddress(sourceMAC), //"00:05:1b:a6:a1:22"),
                    //Destination = new MacAddress("02:00:55:34:03:08"),    // Joe's UXM
                    Destination = new MacAddress(destinationMAC),   //"02:00:55:34:02:43"),      // Tracy's UXM
                    EtherType = EthernetType.IpV6,
                };

            // 4, 0, 5, 7, and 15
            // 0011, 0000, 0101, 0111, 1111
            IpV6Layer ipV6Layer =
                new IpV6Layer
                {
                    //Source = new IpV6Address("2601:245:4002:30a0:0cfd:a476:6039:1cdc"),
                    //Source = new IpV6Address("2001:0:5534:308:c94a:34d0:92da:39eb"),  // IPv6 assigned to Laptop from Joe's UXM router
                    Source = new IpV6Address(sourceIPv6Address),    //"2001:0:5534:243:3867:41f:7f2a:e625"),    // IPV6 assigned to Laptop from Tracy's UXM router
                    //CurrentDestination = new IpV6Address("2001:5:5534:308:0000:0000:0000:5"),   // DUT's IPV6 assigned from UXM
                    CurrentDestination = new IpV6Address(dutIPv6Address),    //"2001:5:5604:0347:0000:0000:0000:5"),   // DUT's IPV6 assigned from UXM
                    FlowLabel = nFlowLabel,
                    HopLimit = 128,
                    NextHeader = IpV4Protocol.IpV6Opts,
                    CustomVersion = bVersion,
                    TrafficClass = bTrafficClass,
                };

            IpV6OptionPadN optpadN = new IpV6OptionPadN(4);

            IpV6Options ipv6options = new IpV6Options(optpadN);

            IpV6ExtensionHeaderHopByHopOptions ipv6ExtensionHeader =
                new IpV6ExtensionHeaderHopByHopOptions(nextHeader, ipv6options);

            // Test Case
            IpV6ExtensionHeaders ipv6ExtHeads = new IpV6ExtensionHeaders(ipv6ExtensionHeader);

            ipV6Layer.ExtensionHeaders = ipv6ExtHeads;




            //ipV6Layer.CustomVersion = 0x04;
            uint uintLayerVariable;
            uintLayerVariable = (uiIdentifier << 16) | uiSequence;

            IcmpIpv6UnknownLayer icmpIpv6Layer = new IcmpIpv6UnknownLayer();
            icmpIpv6Layer.LayerMessageType = 0x80;
            icmpIpv6Layer.LayerCode = 0;
            //icmpIpv6Layer.LayerVariable = 0x0001F001;   // Identifier + Sequence = 00 01 00 84 
            icmpIpv6Layer.LayerVariable = uintLayerVariable;
            icmpIpv6Layer.Payload = new Datagram(Encoding.ASCII.GetBytes(strPayload));
            Console.WriteLine("Checksum: " + icmpIpv6Layer.Checksum);
            Log.Info("Checksum: " + icmpIpv6Layer.Checksum);

            PacketBuilder builder = new PacketBuilder(ethernetLayer, ipV6Layer, icmpIpv6Layer);
            Console.WriteLine("Checksum: " + icmpIpv6Layer.Checksum);
            Log.Info("Checksum: " + icmpIpv6Layer.Checksum);

            Packet newPacket = builder.Build(DateTime.Now);

            return newPacket;
        }

        /// <summary>
        /// This function build an IPv6 over Ethernet with payload packet.
        /// </summary>
        protected Packet NewBuildIpV6PacketGroup2UnrecognizedNextHeaderPacketB(UInt32 uiIdentifier, UInt32 uiSequence, byte bVersion, byte bTrafficClass, int nFlowLabel, String strPayload)
        {
            EthernetLayer ethernetLayer =
                new EthernetLayer
                {
                    Source = new MacAddress(sourceMAC), //"00:05:1b:a6:a1:22"),
                    //Destination = new MacAddress("02:00:55:34:03:08"),    // Joe's UXM
                    Destination = new MacAddress(destinationMAC),   //"02:00:55:34:02:43"),      // Tracy's UXM
                    EtherType = EthernetType.IpV6,
                };

            // 4, 0, 5, 7, and 15
            // 0011, 0000, 0101, 0111, 1111
            IpV6Layer ipV6Layer =
                new IpV6Layer
                {
                    //Source = new IpV6Address("2601:245:4002:30a0:0cfd:a476:6039:1cdc"),
                    //Source = new IpV6Address("2001:0:5534:308:c94a:34d0:92da:39eb"),  // IPv6 assigned to Laptop from Joe's UXM router
                    Source = new IpV6Address(sourceIPv6Address),    //"2001:0:5534:243:3867:41f:7f2a:e625"),    // IPV6 assigned to Laptop from Tracy's UXM router
                    //CurrentDestination = new IpV6Address("2001:5:5534:308:0000:0000:0000:5"),   // DUT's IPV6 assigned from UXM
                    CurrentDestination = new IpV6Address(dutIPv6Address),    //"2001:5:5604:0347:0000:0000:0000:5"),   // DUT's IPV6 assigned from UXM
                    FlowLabel = nFlowLabel,
                    HopLimit = 128,
                    NextHeader = IpV4Protocol.IpV6Opts,
                    CustomVersion = bVersion,
                    TrafficClass = bTrafficClass,
                };

            IpV6OptionPadN optpadN = new IpV6OptionPadN(4);

            IpV6Options ipv6options = new IpV6Options(optpadN);

            IpV6ExtensionHeaderHopByHopOptions ipv6ExtensionHeader =
                new IpV6ExtensionHeaderHopByHopOptions(IpV4Protocol.IpV6Opts, ipv6options);


            IpV6ExtensionHeaderFragmentData ipv6ExtensionHeaderFragment =
                new IpV6ExtensionHeaderFragmentData(IpV4Protocol.InternetControlMessageProtocolForIpV6, 0x10E0, false, 0x0, 0x02);


            // Test Case
            IpV6ExtensionHeaders ipv6ExtHeads = new IpV6ExtensionHeaders(ipv6ExtensionHeader, ipv6ExtensionHeaderFragment);

            ipV6Layer.ExtensionHeaders = ipv6ExtHeads;




            //ipV6Layer.CustomVersion = 0x04;
            uint uintLayerVariable;
            uintLayerVariable = (uiIdentifier << 16) | uiSequence;

            IcmpIpv6UnknownLayer icmpIpv6Layer = new IcmpIpv6UnknownLayer();
            icmpIpv6Layer.LayerMessageType = 0x80;
            icmpIpv6Layer.LayerCode = 0;
            //icmpIpv6Layer.LayerVariable = 0x0001F001;   // Identifier + Sequence = 00 01 00 84 
            icmpIpv6Layer.LayerVariable = uintLayerVariable;
            icmpIpv6Layer.Payload = new Datagram(Encoding.ASCII.GetBytes(strPayload));
            Console.WriteLine("Checksum: " + icmpIpv6Layer.Checksum);
            Log.Info("Checksum: " + icmpIpv6Layer.Checksum);

            PacketBuilder builder = new PacketBuilder(ethernetLayer, ipV6Layer, icmpIpv6Layer);
            Console.WriteLine("Checksum: " + icmpIpv6Layer.Checksum);
            Log.Info("Checksum: " + icmpIpv6Layer.Checksum);

            Packet newPacket = builder.Build(DateTime.Now);

            return newPacket;
        }

        /// <summary>
        /// This function build an IPv6 over Ethernet with payload packet.
        /// </summary>
        protected Packet NewBuildIpV6PacketGroup2ExtensionHeaderPacketA(UInt32 uiIdentifier, UInt32 uiSequence, byte bVersion, byte bTrafficClass, int nFlowLabel, String strPayload)
        {
            EthernetLayer ethernetLayer =
                new EthernetLayer
                {
                    Source = new MacAddress(sourceMAC), //"00:05:1b:a6:a1:22"),
                    //Destination = new MacAddress("02:00:55:34:03:08"),    // Joe's UXM
                    Destination = new MacAddress(destinationMAC),   //"02:00:55:34:02:43"),      // Tracy's UXM
                    EtherType = EthernetType.IpV6,
                };

            // 4, 0, 5, 7, and 15
            // 0011, 0000, 0101, 0111, 1111
            IpV6Layer ipV6Layer =
                new IpV6Layer
                {
                    //Source = new IpV6Address("2601:245:4002:30a0:0cfd:a476:6039:1cdc"),
                    //Source = new IpV6Address("2001:0:5534:308:c94a:34d0:92da:39eb"),  // IPv6 assigned to Laptop from Joe's UXM router
                    Source = new IpV6Address(sourceIPv6Address),    //"2001:0:5534:243:3867:41f:7f2a:e625"),    // IPV6 assigned to Laptop from Tracy's UXM router
                    //CurrentDestination = new IpV6Address("2001:5:5534:308:0000:0000:0000:5"),   // DUT's IPV6 assigned from UXM
                    CurrentDestination = new IpV6Address(dutIPv6Address),    //"2001:5:5604:0347:0000:0000:0000:5"),   // DUT's IPV6 assigned from UXM
                    FlowLabel = nFlowLabel,
                    HopLimit = 128,
                    NextHeader = IpV4Protocol.IpV6HopByHopOption,    //.IpV6HopByHopOption,
                    CustomVersion = bVersion,
                    TrafficClass = bTrafficClass,
                };

            IpV6OptionPadN optpadN = new IpV6OptionPadN(4);

            IpV6Options ipv6options = new IpV6Options(optpadN);

            IpV6ExtensionHeaderHopByHopOptions ipv6HopByHopExtensionHeader =
                new IpV6ExtensionHeaderHopByHopOptions(IpV4Protocol.IpV6Opts, ipv6options);


            // Define IpV6OptionUnknown
            byte[] buffer = {0x00, 0x00, 0x00, 0x00};
            DataSegment dataSegment = new DataSegment(buffer);
            IpV6OptionUnknown optUnknown = new IpV6OptionUnknown((IpV6OptionType)135, dataSegment);

            IpV6Options ipv6options2 = new IpV6Options(optUnknown);

            IpV6ExtensionHeaderDestinationOptions ipv6DestinationOptions =
                new IpV6ExtensionHeaderDestinationOptions(IpV4Protocol.FragmentHeaderForIpV6, ipv6options2);


            // Fragment Header
            IpV6ExtensionHeaderFragmentData ipv6ExtensionHeaderFragment =
                new IpV6ExtensionHeaderFragmentData(IpV4Protocol.InternetControlMessageProtocolForIpV6, 0x0000, true, 0x0, 0x00);


            // Test Case
            IpV6ExtensionHeaders ipv6ExtHeads = new IpV6ExtensionHeaders(ipv6HopByHopExtensionHeader, ipv6DestinationOptions, ipv6ExtensionHeaderFragment);
            //IpV6ExtensionHeaders ipv6ExtHeads = new IpV6ExtensionHeaders(ipv6DestinationOptions);    //, ipv6ExtensionHeaderFragment);

            ipV6Layer.ExtensionHeaders = ipv6ExtHeads;




            //ipV6Layer.CustomVersion = 0x04;
            uint uintLayerVariable;
            uintLayerVariable = (uiIdentifier << 16) | uiSequence;

            IcmpIpv6UnknownLayer icmpIpv6Layer = new IcmpIpv6UnknownLayer();
            icmpIpv6Layer.LayerMessageType = 0x80;
            icmpIpv6Layer.LayerCode = 0;
            //icmpIpv6Layer.LayerVariable = 0x0001F001;   // Identifier + Sequence = 00 01 00 84 
            icmpIpv6Layer.LayerVariable = uintLayerVariable;
            icmpIpv6Layer.Payload = new Datagram(Encoding.ASCII.GetBytes(strPayload));
            Console.WriteLine("Checksum: " + icmpIpv6Layer.Checksum);
            Log.Info("Checksum: " + icmpIpv6Layer.Checksum);

            PacketBuilder builder = new PacketBuilder(ethernetLayer, ipV6Layer, icmpIpv6Layer);
            Console.WriteLine("Checksum: " + icmpIpv6Layer.Checksum);
            Log.Info("Checksum: " + icmpIpv6Layer.Checksum);

            Packet newPacket = builder.Build(DateTime.Now);

            return newPacket;
        }

        /// <summary>
        /// This function build an IPv6 over Ethernet with payload packet.
        /// </summary>
        protected Packet NewBuildIpV6PacketGroup2ExtensionHeaderPacketB(UInt32 uiIdentifier, UInt32 uiSequence, byte bVersion, byte bTrafficClass, int nFlowLabel, String strPayload)
        {
            EthernetLayer ethernetLayer =
                new EthernetLayer
                {
                    Source = new MacAddress(sourceMAC), //"00:05:1b:a6:a1:22"),
                    Destination = new MacAddress(destinationMAC),   //"02:00:55:34:02:43"),      // Tracy's UXM
                    EtherType = EthernetType.IpV6,
                };

            // 4, 0, 5, 7, and 15
            // 0011, 0000, 0101, 0111, 1111
            IpV6Layer ipV6Layer =
                new IpV6Layer
                {
                    Source = new IpV6Address(sourceIPv6Address),    //"2001:0:5534:243:3867:41f:7f2a:e625"),    // IPV6 assigned to Laptop from Tracy's UXM router
                    CurrentDestination = new IpV6Address(dutIPv6Address),    //"2001:5:5604:0347:0000:0000:0000:5"),   // DUT's IPV6 assigned from UXM
                    FlowLabel = nFlowLabel,
                    HopLimit = 128,
                    NextHeader = IpV4Protocol.IpV6HopByHopOption,    //.IpV6HopByHopOption,
                    CustomVersion = bVersion,
                    TrafficClass = bTrafficClass,
                };

            IpV6OptionPadN optpadN = new IpV6OptionPadN(4);

            IpV6Options ipv6options = new IpV6Options(optpadN);

            IpV6ExtensionHeaderHopByHopOptions ipv6ExtensionHeader =
                new IpV6ExtensionHeaderHopByHopOptions(IpV4Protocol.IpV6Opts, ipv6options);


            // Define IpV6OptionUnknown
            byte[] buffer = { 0x00, 0x00, 0x00, 0x00 };
            DataSegment dataSegment = new DataSegment(buffer);
            IpV6OptionUnknown optUnknown = new IpV6OptionUnknown((IpV6OptionType)7, dataSegment);

            IpV6Options ipv6options2 = new IpV6Options(optUnknown);

            IpV6ExtensionHeaderDestinationOptions ipv6DestinationOptions =
                new IpV6ExtensionHeaderDestinationOptions(IpV4Protocol.FragmentHeaderForIpV6, ipv6options2);


            // Fragment Header
            IpV6ExtensionHeaderFragmentData ipv6ExtensionHeaderFragment =
                new IpV6ExtensionHeaderFragmentData(IpV4Protocol.InternetControlMessageProtocolForIpV6, 0x0000, true, 0x0, 0x00);


            // Test Case
            IpV6ExtensionHeaders ipv6ExtHeads = new IpV6ExtensionHeaders(ipv6ExtensionHeader, ipv6DestinationOptions, ipv6ExtensionHeaderFragment);
            //IpV6ExtensionHeaders ipv6ExtHeads = new IpV6ExtensionHeaders(ipv6DestinationOptions);    //, ipv6ExtensionHeaderFragment);

            ipV6Layer.ExtensionHeaders = ipv6ExtHeads;




            //ipV6Layer.CustomVersion = 0x04;
            uint uintLayerVariable;
            uintLayerVariable = (uiIdentifier << 16) | uiSequence;

            IcmpIpv6UnknownLayer icmpIpv6Layer = new IcmpIpv6UnknownLayer();
            icmpIpv6Layer.LayerMessageType = 0x80;
            icmpIpv6Layer.LayerCode = 0;
            //icmpIpv6Layer.LayerVariable = 0x0001F001;   // Identifier + Sequence = 00 01 00 84 
            icmpIpv6Layer.LayerVariable = uintLayerVariable;
            icmpIpv6Layer.Payload = new Datagram(Encoding.ASCII.GetBytes(strPayload));
            Console.WriteLine("Checksum: " + icmpIpv6Layer.Checksum);
            Log.Info("Checksum: " + icmpIpv6Layer.Checksum);

            PacketBuilder builder = new PacketBuilder(ethernetLayer, ipV6Layer, icmpIpv6Layer);
            Console.WriteLine("Checksum: " + icmpIpv6Layer.Checksum);
            Log.Info("Checksum: " + icmpIpv6Layer.Checksum);

            Packet newPacket = builder.Build(DateTime.Now);

            return newPacket;
        }

        /// <summary>
        /// This function build an IPv6 over Ethernet with payload packet.
        /// </summary>
        protected Packet NewBuildIpV6PacketGroup2ExtensionHeaderPacketC(UInt32 uiIdentifier, UInt32 uiSequence, byte bVersion, byte bTrafficClass, int nFlowLabel, String strPayload)
        {
            EthernetLayer ethernetLayer =
                new EthernetLayer
                {
                    Source = new MacAddress(sourceMAC), //"00:05:1b:a6:a1:22"),
                    Destination = new MacAddress(destinationMAC),   //"02:00:55:34:02:43"),      // Tracy's UXM
                    EtherType = EthernetType.IpV6,
                };

            // 4, 0, 5, 7, and 15
            // 0011, 0000, 0101, 0111, 1111
            IpV6Layer ipV6Layer =
                new IpV6Layer
                {
                    Source = new IpV6Address(sourceIPv6Address),    //"2001:0:5534:243:3867:41f:7f2a:e625"),    // IPV6 assigned to Laptop from Tracy's UXM router
                    CurrentDestination = new IpV6Address(dutIPv6Address),    //"2001:5:5604:0347:0000:0000:0000:5"),   // DUT's IPV6 assigned from UXM
                    FlowLabel = nFlowLabel,
                    HopLimit = 128,
                    NextHeader = IpV4Protocol.IpV6HopByHopOption,    //.IpV6HopByHopOption,
                    CustomVersion = bVersion,
                    TrafficClass = bTrafficClass,
                };

            IpV6OptionPadN optpadN = new IpV6OptionPadN(4);

            IpV6Options ipv6options = new IpV6Options(optpadN);

            IpV6ExtensionHeaderHopByHopOptions ipv6ExtensionHeader =
                new IpV6ExtensionHeaderHopByHopOptions(IpV4Protocol.FragmentHeaderForIpV6, ipv6options);


            // Fragment Header
            IpV6ExtensionHeaderFragmentData ipv6ExtensionHeaderFragment =
                new IpV6ExtensionHeaderFragmentData(IpV4Protocol.IpV6Opts, 0x0000, true, 0x0, 0x00);



            // Define IpV6OptionUnknown
            byte[] buffer = { 0x00, 0x00, 0x00, 0x00 };
            DataSegment dataSegment = new DataSegment(buffer);
            IpV6OptionUnknown optUnknown = new IpV6OptionUnknown((IpV6OptionType)135, dataSegment);

            IpV6Options ipv6options2 = new IpV6Options(optUnknown);

            IpV6ExtensionHeaderDestinationOptions ipv6DestinationOptions =
                new IpV6ExtensionHeaderDestinationOptions(IpV4Protocol.InternetControlMessageProtocolForIpV6, ipv6options2);


            // Test Case
            IpV6ExtensionHeaders ipv6ExtHeads = new IpV6ExtensionHeaders(ipv6ExtensionHeader, ipv6ExtensionHeaderFragment, ipv6DestinationOptions);

            ipV6Layer.ExtensionHeaders = ipv6ExtHeads;




            //ipV6Layer.CustomVersion = 0x04;
            uint uintLayerVariable;
            uintLayerVariable = (uiIdentifier << 16) | uiSequence;

            IcmpIpv6UnknownLayer icmpIpv6Layer = new IcmpIpv6UnknownLayer();
            icmpIpv6Layer.LayerMessageType = 0x80;
            icmpIpv6Layer.LayerCode = 0;
            //icmpIpv6Layer.LayerVariable = 0x0001F001;   // Identifier + Sequence = 00 01 00 84 
            icmpIpv6Layer.LayerVariable = uintLayerVariable;
            icmpIpv6Layer.Payload = new Datagram(Encoding.ASCII.GetBytes(strPayload));
            Console.WriteLine("Checksum: " + icmpIpv6Layer.Checksum);
            Log.Info("Checksum: " + icmpIpv6Layer.Checksum);

            PacketBuilder builder = new PacketBuilder(ethernetLayer, ipV6Layer, icmpIpv6Layer);
            Console.WriteLine("Checksum: " + icmpIpv6Layer.Checksum);
            Log.Info("Checksum: " + icmpIpv6Layer.Checksum);

            Packet newPacket = builder.Build(DateTime.Now);

            return newPacket;
        }

        /// <summary>
        /// This function build an IPv6 over Ethernet with payload packet.
        /// </summary>
        protected Packet NewBuildIpV6PacketGroup2ExtensionHeaderPacketD(UInt32 uiIdentifier, UInt32 uiSequence, byte bVersion, byte bTrafficClass, int nFlowLabel, String strPayload)
        {
            EthernetLayer ethernetLayer =
                new EthernetLayer
                {
                    Source = new MacAddress(sourceMAC), //"00:05:1b:a6:a1:22"),
                    Destination = new MacAddress(destinationMAC),   //"02:00:55:34:02:43"),      // Tracy's UXM
                    EtherType = EthernetType.IpV6,
                };

            // 4, 0, 5, 7, and 15
            // 0011, 0000, 0101, 0111, 1111
            IpV6Layer ipV6Layer =
                new IpV6Layer
                {
                    Source = new IpV6Address(sourceIPv6Address),    //"2001:0:5534:243:3867:41f:7f2a:e625"),    // IPV6 assigned to Laptop from Tracy's UXM router
                    CurrentDestination = new IpV6Address(dutIPv6Address),    //"2001:5:5604:0347:0000:0000:0000:5"),   // DUT's IPV6 assigned from UXM
                    FlowLabel = nFlowLabel,
                    HopLimit = 128,
                    NextHeader = IpV4Protocol.IpV6HopByHopOption,    //.IpV6HopByHopOption,
                    CustomVersion = bVersion,
                    TrafficClass = bTrafficClass,
                };

            IpV6OptionPadN optpadN = new IpV6OptionPadN(4);

            IpV6Options ipv6options = new IpV6Options(optpadN);

            IpV6ExtensionHeaderHopByHopOptions ipv6ExtensionHeader =
                new IpV6ExtensionHeaderHopByHopOptions(IpV4Protocol.FragmentHeaderForIpV6, ipv6options);


            // Fragment Header
            IpV6ExtensionHeaderFragmentData ipv6ExtensionHeaderFragment =
                new IpV6ExtensionHeaderFragmentData(IpV4Protocol.IpV6Opts, 0x0000, false, 0x0, 0x00);



            // Define IpV6OptionUnknown
            byte[] buffer = { 0x00, 0x00, 0x00, 0x00 };
            DataSegment dataSegment = new DataSegment(buffer);
            IpV6OptionUnknown optUnknown = new IpV6OptionUnknown((IpV6OptionType)135, dataSegment);

            IpV6Options ipv6options2 = new IpV6Options(optUnknown);

            IpV6ExtensionHeaderDestinationOptions ipv6DestinationOptions =
                new IpV6ExtensionHeaderDestinationOptions(IpV4Protocol.InternetControlMessageProtocolForIpV6, ipv6options2);


            // Test Case
            IpV6ExtensionHeaders ipv6ExtHeads = new IpV6ExtensionHeaders(ipv6ExtensionHeader, ipv6ExtensionHeaderFragment, ipv6DestinationOptions);

            ipV6Layer.ExtensionHeaders = ipv6ExtHeads;




            //ipV6Layer.CustomVersion = 0x04;
            uint uintLayerVariable;
            uintLayerVariable = (uiIdentifier << 16) | uiSequence;

            IcmpIpv6UnknownLayer icmpIpv6Layer = new IcmpIpv6UnknownLayer();
            icmpIpv6Layer.LayerMessageType = 0x80;
            icmpIpv6Layer.LayerCode = 0;
            //icmpIpv6Layer.LayerVariable = 0x0001F001;   // Identifier + Sequence = 00 01 00 84 
            icmpIpv6Layer.LayerVariable = uintLayerVariable;
            icmpIpv6Layer.Payload = new Datagram(Encoding.ASCII.GetBytes(strPayload));
            Console.WriteLine("Checksum: " + icmpIpv6Layer.Checksum);
            Log.Info("Checksum: " + icmpIpv6Layer.Checksum);

            PacketBuilder builder = new PacketBuilder(ethernetLayer, ipV6Layer, icmpIpv6Layer);
            Console.WriteLine("Checksum: " + icmpIpv6Layer.Checksum);
            Log.Info("Checksum: " + icmpIpv6Layer.Checksum);

            Packet newPacket = builder.Build(DateTime.Now);

            return newPacket;
        }

        /// <summary>
        /// This function build an IPv6 over Ethernet with payload packet.
        /// </summary>
        protected Packet NewBuildIpV6PacketGroup2OptionProcessingOrder(UInt32 uiIdentifier, UInt32 uiSequence, byte bVersion, byte bTrafficClass, int nFlowLabel, String strPayload, int nPacketType)
        {
            EthernetLayer ethernetLayer =
                new EthernetLayer
                {
                    Source = new MacAddress(sourceMAC), //"00:05:1b:a6:a1:22"),
                    Destination = new MacAddress(destinationMAC),   //"02:00:55:34:02:43"),      // Tracy's UXM
                    EtherType = EthernetType.IpV6,
                };

            // 4, 0, 5, 7, and 15
            // 0011, 0000, 0101, 0111, 1111
            IpV6Layer ipV6Layer =
                new IpV6Layer
                {
                    Source = new IpV6Address(sourceIPv6Address),    //"2001:0:5534:243:3867:41f:7f2a:e625"),    // IPV6 assigned to Laptop from Tracy's UXM router
                    CurrentDestination = new IpV6Address(dutIPv6Address),    //"2001:5:5604:0347:0000:0000:0000:5"),   // DUT's IPV6 assigned from UXM
                    FlowLabel = nFlowLabel,
                    HopLimit = 128,
                    NextHeader = IpV4Protocol.IpV6Opts,
                    CustomVersion = bVersion,
                    TrafficClass = bTrafficClass,
                };

            // Define IpV6OptionUnknown
            byte[] buffer4 = { 0x00, 0x00, 0x00, 0x00 };
            byte[] buffer6 = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
            DataSegment dataSegment4 = new DataSegment(buffer4);
            DataSegment dataSegment6 = new DataSegment(buffer6);
            IpV6OptionUnknown opt7Unknown = new IpV6OptionUnknown((IpV6OptionType)7, dataSegment4);
            IpV6OptionUnknown opt71Unknown = new IpV6OptionUnknown((IpV6OptionType)71, dataSegment6);
            IpV6OptionUnknown opt135Unknown = new IpV6OptionUnknown((IpV6OptionType)135, dataSegment6);
            IpV6OptionUnknown opt199Unknown = new IpV6OptionUnknown((IpV6OptionType)199, dataSegment6);

            IpV6Options ipv6options;
            if (nPacketType == 0)
            {
                ipv6options = new IpV6Options(opt7Unknown, opt71Unknown, opt135Unknown, opt199Unknown);
            }
            else if (nPacketType == 1)
            {
                ipv6options = new IpV6Options(opt7Unknown, opt135Unknown, opt199Unknown, opt71Unknown);
            }
            else if (nPacketType == 2)
            {
                ipv6options = new IpV6Options(opt7Unknown, opt199Unknown, opt71Unknown, opt135Unknown);
            }
            else
            {
                throw new Exception("Unknown Packet type on NewBuildIpV6PacketGroup2OptionProcessingOrder");
            }

            IpV6ExtensionHeaderDestinationOptions ipv6DestinationOptions =
                new IpV6ExtensionHeaderDestinationOptions(IpV4Protocol.InternetControlMessageProtocolForIpV6, ipv6options);


            // Test Case
            IpV6ExtensionHeaders ipv6ExtHeads = new IpV6ExtensionHeaders(ipv6DestinationOptions);

            ipV6Layer.ExtensionHeaders = ipv6ExtHeads;




            //ipV6Layer.CustomVersion = 0x04;
            uint uintLayerVariable;
            uintLayerVariable = (uiIdentifier << 16) | uiSequence;

            IcmpIpv6UnknownLayer icmpIpv6Layer = new IcmpIpv6UnknownLayer();
            icmpIpv6Layer.LayerMessageType = 0x80;
            icmpIpv6Layer.LayerCode = 0;
            //icmpIpv6Layer.LayerVariable = 0x0001F001;   // Identifier + Sequence = 00 01 00 84 
            icmpIpv6Layer.LayerVariable = uintLayerVariable;
            icmpIpv6Layer.Payload = new Datagram(Encoding.ASCII.GetBytes(strPayload));
            Console.WriteLine("Checksum: " + icmpIpv6Layer.Checksum);
            Log.Info("Checksum: " + icmpIpv6Layer.Checksum);

            PacketBuilder builder = new PacketBuilder(ethernetLayer, ipV6Layer, icmpIpv6Layer);
            Console.WriteLine("Checksum: " + icmpIpv6Layer.Checksum);
            Log.Info("Checksum: " + icmpIpv6Layer.Checksum);

            Packet newPacket = builder.Build(DateTime.Now);

            return newPacket;
        }

        /// <summary>
        /// This function build an IPv6 over Ethernet with payload packet.
        /// </summary>
        protected Packet NewBuildIpV6PacketGroup2OptionProcessingDestinationOptions(UInt32 uiIdentifier, UInt32 uiSequence, byte bVersion, byte bTrafficClass, int nFlowLabel, String strPayload, int nPacketType)
        {
            EthernetLayer ethernetLayer =
                new EthernetLayer
                {
                    Source = new MacAddress(sourceMAC), //"00:05:1b:a6:a1:22"),
                    Destination = new MacAddress(destinationMAC),   //"02:00:55:34:02:43"),      // Tracy's UXM
                    EtherType = EthernetType.IpV6,
                };

            // 4, 0, 5, 7, and 15
            // 0011, 0000, 0101, 0111, 1111
            IpV6Layer ipV6Layer =
                new IpV6Layer
                {
                    Source = new IpV6Address(sourceIPv6Address),    //"2001:0:5534:243:3867:41f:7f2a:e625"),    // IPV6 assigned to Laptop from Tracy's UXM router
                    CurrentDestination = new IpV6Address(dutIPv6Address),    //"2001:5:5604:0347:0000:0000:0000:5"),   // DUT's IPV6 assigned from UXM
                    FlowLabel = nFlowLabel,
                    HopLimit = 128,
                    NextHeader = IpV4Protocol.IpV6Opts,
                    CustomVersion = bVersion,
                    TrafficClass = bTrafficClass,
                };

            // Define IpV6OptionUnknown
            IpV6OptionPad1 optpad1 = new IpV6OptionPad1();
            IpV6OptionPadN optpadN = new IpV6OptionPadN(4);
            byte[] buffer4 = { 0x00, 0x00, 0x00, 0x00 };
            DataSegment dataSegment4 = new DataSegment(buffer4);
            IpV6OptionUnknown opt7Unknown = new IpV6OptionUnknown((IpV6OptionType)7, dataSegment4);
            IpV6OptionUnknown opt71Unknown = new IpV6OptionUnknown((IpV6OptionType)71, dataSegment4);
            IpV6OptionUnknown opt135Unknown = new IpV6OptionUnknown((IpV6OptionType)135, dataSegment4);
            IpV6OptionUnknown opt199Unknown = new IpV6OptionUnknown((IpV6OptionType)199, dataSegment4);

            IpV6Options ipv6options;
            if (nPacketType == 0)
            {
                ipv6options = new IpV6Options(optpad1, optpad1, optpad1, optpad1, optpad1, optpad1);
            }
            else if (nPacketType == 1)
            {
                ipv6options = new IpV6Options(optpadN);
            }
            else if (nPacketType == 2)
            {
                ipv6options = new IpV6Options(opt7Unknown);
            }
            else if (nPacketType == 3)
            {
                ipv6options = new IpV6Options(opt71Unknown);
            }
            else if (nPacketType == 4)
            {
                ipv6options = new IpV6Options(opt135Unknown);
            }
            else if (nPacketType == 5)
            {
                ipv6options = new IpV6Options(opt199Unknown);
            }
            else
            {
                throw new Exception("Unknown Packet type on NewBuildIpV6PacketGroup2OptionProcessingOrder");
            }

            IpV6ExtensionHeaderDestinationOptions ipv6DestinationOptions =
                new IpV6ExtensionHeaderDestinationOptions(IpV4Protocol.InternetControlMessageProtocolForIpV6, ipv6options);


            // Test Case
            IpV6ExtensionHeaders ipv6ExtHeads = new IpV6ExtensionHeaders(ipv6DestinationOptions);

            ipV6Layer.ExtensionHeaders = ipv6ExtHeads;




            //ipV6Layer.CustomVersion = 0x04;
            uint uintLayerVariable;
            uintLayerVariable = (uiIdentifier << 16) | uiSequence;

            IcmpIpv6UnknownLayer icmpIpv6Layer = new IcmpIpv6UnknownLayer();
            icmpIpv6Layer.LayerMessageType = 0x80;
            icmpIpv6Layer.LayerCode = 0;
            //icmpIpv6Layer.LayerVariable = 0x0001F001;   // Identifier + Sequence = 00 01 00 84 
            icmpIpv6Layer.LayerVariable = uintLayerVariable;
            icmpIpv6Layer.Payload = new Datagram(Encoding.ASCII.GetBytes(strPayload));
            Console.WriteLine("Checksum: " + icmpIpv6Layer.Checksum);
            Log.Info("Checksum: " + icmpIpv6Layer.Checksum);

            PacketBuilder builder = new PacketBuilder(ethernetLayer, ipV6Layer, icmpIpv6Layer);
            Console.WriteLine("Checksum: " + icmpIpv6Layer.Checksum);
            Log.Info("Checksum: " + icmpIpv6Layer.Checksum);

            Packet newPacket = builder.Build(DateTime.Now);

            return newPacket;
        }

        /// <summary>
        /// This function build an IPv6 over Ethernet with payload packet.
        /// </summary>
        protected Packet NewBuildIpV6PacketGroup3FragmentReassembly(UInt32 uiIdentifier, UInt32 uiSequence, byte bVersion, byte bTrafficClass, int nFlowLabel, int nPacketType)
        {
            String strPayload = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" +
                                "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb";
            EthernetLayer ethernetLayer =
                new EthernetLayer
                {
                    Source = new MacAddress(sourceMAC), //"00:05:1b:a6:a1:22"),
                    Destination = new MacAddress(destinationMAC),   //"02:00:55:34:02:43"),      // Tracy's UXM
                    EtherType = EthernetType.IpV6,
                };

            // 4, 0, 5, 7, and 15
            // 0011, 0000, 0101, 0111, 1111
            IpV6Layer ipV6Layer =
                new IpV6Layer
                {
                    Source = new IpV6Address(sourceIPv6Address),    //"2001:0:5534:243:3867:41f:7f2a:e625"),    // IPV6 assigned to Laptop from Tracy's UXM router
                    CurrentDestination = new IpV6Address(dutIPv6Address),    //"2001:5:5604:0347:0000:0000:0000:5"),   // DUT's IPV6 assigned from UXM
                    FlowLabel = nFlowLabel,
                    HopLimit = 128,
                    NextHeader = IpV4Protocol.InternetControlMessageProtocolForIpV6,
                    CustomVersion = bVersion,
                    TrafficClass = bTrafficClass,
                };

            // 4, 0, 5, 7, and 15
            // 0011, 0000, 0101, 0111, 1111
            IpV6Layer ipV6LayerFragment =
                new IpV6Layer
                {
                    Source = new IpV6Address(sourceIPv6Address),    //"2001:0:5534:243:3867:41f:7f2a:e625"),    // IPV6 assigned to Laptop from Tracy's UXM router
                    CurrentDestination = new IpV6Address(dutIPv6Address),    //"2001:5:5604:0347:0000:0000:0000:5"),   // DUT's IPV6 assigned from UXM
                    FlowLabel = nFlowLabel,
                    HopLimit = 128,
                    NextHeader = IpV4Protocol.FragmentHeaderForIpV6,
                    CustomVersion = bVersion,
                    TrafficClass = bTrafficClass,
                };


            // Fragment Header
            IpV6ExtensionHeaderFragmentData ipv6ExtensionHeaderFragment;
            if (nPacketType == 0)
            {
                ipv6ExtensionHeaderFragment = new IpV6ExtensionHeaderFragmentData(IpV4Protocol.InternetControlMessageProtocolForIpV6, 0x0000, true, 0x01, 0x00);
            }
            else if (nPacketType == 1)
            {
                ipv6ExtensionHeaderFragment = new IpV6ExtensionHeaderFragmentData(IpV4Protocol.InternetControlMessageProtocolForIpV6, 0x0004, true, 0x01, 0x00);
            }
            else if (nPacketType == 2)
            {
                ipv6ExtensionHeaderFragment = new IpV6ExtensionHeaderFragmentData(IpV4Protocol.InternetControlMessageProtocolForIpV6, 0x0008, false, 0x01, 0x00);
            }
            else if (nPacketType == 3)
            {
                ipv6ExtensionHeaderFragment = new IpV6ExtensionHeaderFragmentData(IpV4Protocol.InternetControlMessageProtocolForIpV6, 0x0000, true, 0x01, 0x00);
            }
            else if (nPacketType == 4)
            {
                ipv6ExtensionHeaderFragment = new IpV6ExtensionHeaderFragmentData(IpV4Protocol.InternetControlMessageProtocolForIpV6, 0x0000, true, 0x01, 0x00);
            }
            else
            {
                throw new Exception("Unknown Packet type on NewBuildIpV6PacketGroup3FragmentReassembly");
            }


            // Test Case
            IpV6ExtensionHeaders ipv6ExtHeads = new IpV6ExtensionHeaders(ipv6ExtensionHeaderFragment);

            ipV6LayerFragment.ExtensionHeaders = ipv6ExtHeads;




            //ipV6Layer.CustomVersion = 0x04;
            uint uintLayerVariable;
            uintLayerVariable = (uiIdentifier << 16) | uiSequence;

            IcmpIpv6UnknownLayer icmpIpv6Layer = new IcmpIpv6UnknownLayer();
            icmpIpv6Layer.LayerMessageType = 0x80;
            icmpIpv6Layer.LayerCode = 0;
            //icmpIpv6Layer.LayerVariable = 0x0001F001;   // Identifier + Sequence = 00 01 00 84 
            icmpIpv6Layer.LayerVariable = uintLayerVariable;
            icmpIpv6Layer.Payload = new Datagram(Encoding.ASCII.GetBytes(strPayload));
            Console.WriteLine("Checksum: " + icmpIpv6Layer.Checksum);
            Log.Info("Checksum: " + icmpIpv6Layer.Checksum);

            Console.WriteLine("Checksum: " + icmpIpv6Layer.Checksum);
            Log.Info("Checksum: " + icmpIpv6Layer.Checksum);

            PacketBuilder builder = new PacketBuilder(ethernetLayer, ipV6Layer, icmpIpv6Layer);
            Packet newPacket = builder.Build(DateTime.Now);

            PayloadLayer payloadFragmented;
            PacketBuilder builderFragmented;
            byte[] newBuffer = newPacket.Ethernet.IpV6.Payload.ToArray();
            if (nPacketType == 0)
            {
                payloadFragmented = new PayloadLayer { Data = new Datagram(newBuffer, 0, 32) };
                builderFragmented = new PacketBuilder(ethernetLayer, ipV6LayerFragment, payloadFragmented);
            }
            else if (nPacketType == 1)
            {
                payloadFragmented = new PayloadLayer { Data = new Datagram(newBuffer, 32, 32) };
                builderFragmented = new PacketBuilder(ethernetLayer, ipV6LayerFragment, payloadFragmented);
            }
            else if (nPacketType == 2)
            {
                payloadFragmented = new PayloadLayer { Data = new Datagram(newBuffer, 64, 24) };
                builderFragmented = new PacketBuilder(ethernetLayer, ipV6LayerFragment, payloadFragmented);
            }
            else if (nPacketType == 3)
            {
                return newPacket;
            }
            else if (nPacketType == 4)
            {
                builderFragmented = new PacketBuilder(ethernetLayer, ipV6LayerFragment, icmpIpv6Layer);
                return builderFragmented.Build(DateTime.Now);
            }
            else
            {
                throw new Exception("Unknown Packet type on NewBuildIpV6PacketGroup3FragmentReassembly");
            }
            Packet packetFragmented = builderFragmented.Build(DateTime.Now);


            return packetFragmented;
        }

        /// <summary>
        /// This function build an IPv6 over Ethernet with payload packet.
        /// </summary>
        protected Packet NewBuildIpV6PacketGroup3ReassemblyTime(UInt32 uiIdentifier, UInt32 uiSequence, byte bVersion, byte bTrafficClass, int nFlowLabel, int nPacketType, DateTime dtDate)
        {
            String strPayload = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" +
                                "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb";
            EthernetLayer ethernetLayer =
                new EthernetLayer
                {
                    Source = new MacAddress(sourceMAC), //"00:05:1b:a6:a1:22"),
                    Destination = new MacAddress(destinationMAC),   //"02:00:55:34:02:43"),      // Tracy's UXM
                    EtherType = EthernetType.IpV6,
                };

            // 4, 0, 5, 7, and 15
            // 0011, 0000, 0101, 0111, 1111
            IpV6Layer ipV6Layer =
                new IpV6Layer
                {
                    Source = new IpV6Address(sourceIPv6Address),    //"2001:0:5534:243:3867:41f:7f2a:e625"),    // IPV6 assigned to Laptop from Tracy's UXM router
                    CurrentDestination = new IpV6Address(dutIPv6Address),    //"2001:5:5604:0347:0000:0000:0000:5"),   // DUT's IPV6 assigned from UXM
                    FlowLabel = nFlowLabel,
                    HopLimit = 128,
                    NextHeader = IpV4Protocol.InternetControlMessageProtocolForIpV6,
                    CustomVersion = bVersion,
                    TrafficClass = bTrafficClass,
                };

            // 4, 0, 5, 7, and 15
            // 0011, 0000, 0101, 0111, 1111
            IpV6Layer ipV6LayerFragment =
                new IpV6Layer
                {
                    Source = new IpV6Address(sourceIPv6Address),    //"2001:0:5534:243:3867:41f:7f2a:e625"),    // IPV6 assigned to Laptop from Tracy's UXM router
                    CurrentDestination = new IpV6Address(dutIPv6Address),    //"2001:5:5604:0347:0000:0000:0000:5"),   // DUT's IPV6 assigned from UXM
                    FlowLabel = nFlowLabel,
                    HopLimit = 128,
                    NextHeader = IpV4Protocol.FragmentHeaderForIpV6,
                    CustomVersion = bVersion,
                    TrafficClass = bTrafficClass,
                };


            // Fragment Header
            IpV6ExtensionHeaderFragmentData ipv6ExtensionHeaderFragment;
            if (nPacketType == 0)
            {
                ipv6ExtensionHeaderFragment = new IpV6ExtensionHeaderFragmentData(IpV4Protocol.InternetControlMessageProtocolForIpV6, 0x0000, true, 0x01, 0x00);
            }
            else if (nPacketType == 1)
            {
                ipv6ExtensionHeaderFragment = new IpV6ExtensionHeaderFragmentData(IpV4Protocol.InternetControlMessageProtocolForIpV6, 0x0004, true, 0x01, 0x00);
            }
            else if (nPacketType == 2)
            {
                ipv6ExtensionHeaderFragment = new IpV6ExtensionHeaderFragmentData(IpV4Protocol.InternetControlMessageProtocolForIpV6, 0x0008, false, 0x01, 0x00);
            }
            else if (nPacketType == 3)
            {
                ipv6ExtensionHeaderFragment = new IpV6ExtensionHeaderFragmentData(IpV4Protocol.InternetControlMessageProtocolForIpV6, 0x0000, true, 0x01, 0x00);
            }
            else if (nPacketType == 4)
            {
                ipv6ExtensionHeaderFragment = new IpV6ExtensionHeaderFragmentData(IpV4Protocol.InternetControlMessageProtocolForIpV6, 0x0000, true, 0x01, 0x00);
            }
            else
            {
                throw new Exception("Unknown Packet type on NewBuildIpV6PacketGroup3FragmentReassembly");
            }


            // Test Case
            IpV6ExtensionHeaders ipv6ExtHeads = new IpV6ExtensionHeaders(ipv6ExtensionHeaderFragment);

            ipV6LayerFragment.ExtensionHeaders = ipv6ExtHeads;




            //ipV6Layer.CustomVersion = 0x04;
            uint uintLayerVariable;
            uintLayerVariable = (uiIdentifier << 16) | uiSequence;

            IcmpIpv6UnknownLayer icmpIpv6Layer = new IcmpIpv6UnknownLayer();
            icmpIpv6Layer.LayerMessageType = 0x80;
            icmpIpv6Layer.LayerCode = 0;
            //icmpIpv6Layer.LayerVariable = 0x0001F001;   // Identifier + Sequence = 00 01 00 84 
            icmpIpv6Layer.LayerVariable = uintLayerVariable;
            icmpIpv6Layer.Payload = new Datagram(Encoding.ASCII.GetBytes(strPayload));
            Console.WriteLine("Checksum: " + icmpIpv6Layer.Checksum);
            Log.Info("Checksum: " + icmpIpv6Layer.Checksum);

            Console.WriteLine("Checksum: " + icmpIpv6Layer.Checksum);
            Log.Info("Checksum: " + icmpIpv6Layer.Checksum);

            PacketBuilder builder = new PacketBuilder(ethernetLayer, ipV6Layer, icmpIpv6Layer);
            Packet newPacket = builder.Build(DateTime.Now);

            PayloadLayer payloadFragmented;
            PacketBuilder builderFragmented;
            byte[] newBuffer = newPacket.Ethernet.IpV6.Payload.ToArray();
            if (nPacketType == 0)
            {
                payloadFragmented = new PayloadLayer { Data = new Datagram(newBuffer, 0, 32) };
                builderFragmented = new PacketBuilder(ethernetLayer, ipV6LayerFragment, payloadFragmented);
            }
            else if (nPacketType == 1)
            {
                payloadFragmented = new PayloadLayer { Data = new Datagram(newBuffer, 32, 32) };
                builderFragmented = new PacketBuilder(ethernetLayer, ipV6LayerFragment, payloadFragmented);
            }
            else if (nPacketType == 2)
            {
                payloadFragmented = new PayloadLayer { Data = new Datagram(newBuffer, 64, 24) };
                builderFragmented = new PacketBuilder(ethernetLayer, ipV6LayerFragment, payloadFragmented);
            }
            else if (nPacketType == 3)
            {
                return newPacket;
            }
            else if (nPacketType == 4)
            {
                builderFragmented = new PacketBuilder(ethernetLayer, ipV6LayerFragment, icmpIpv6Layer);
                return builderFragmented.Build(DateTime.Now);
            }
            else
            {
                throw new Exception("Unknown Packet type on NewBuildIpV6PacketGroup3FragmentReassembly");
            }
            Packet packetFragmented = builderFragmented.Build(dtDate);


            return packetFragmented;
        }

        /// <summary>
        /// This function build an IPv6 over Ethernet with payload packet.
        /// </summary>
        protected Packet NewBuildIpV6PacketGroup3Fragment(UInt32 uiIdentifier, UInt32 uiSequence, byte bVersion, byte bTrafficClass, int nFlowLabel, String strPayload)
        {
            EthernetLayer ethernetLayer =
                new EthernetLayer
                {
                    Source = new MacAddress(sourceMAC), //"00:05:1b:a6:a1:22"),
                    Destination = new MacAddress(destinationMAC),   //"02:00:55:34:02:43"),      // Tracy's UXM
                    EtherType = EthernetType.IpV6,
                };

            // 4, 0, 5, 7, and 15
            // 0011, 0000, 0101, 0111, 1111
            IpV6Layer ipV6Layer =
                new IpV6Layer
                {
                    Source = new IpV6Address(sourceIPv6Address),    //"2001:0:5534:243:3867:41f:7f2a:e625"),    // IPV6 assigned to Laptop from Tracy's UXM router
                    CurrentDestination = new IpV6Address(dutIPv6Address),    //"2001:5:5604:0347:0000:0000:0000:5"),   // DUT's IPV6 assigned from UXM
                    FlowLabel = nFlowLabel,
                    HopLimit = 128,
                    NextHeader = IpV4Protocol.IpV6HopByHopOption,    //.IpV6HopByHopOption,
                    CustomVersion = bVersion,
                    TrafficClass = bTrafficClass,
                };

            IpV6OptionPadN optpadN = new IpV6OptionPadN(4);

            IpV6Options ipv6options = new IpV6Options(optpadN);

            IpV6ExtensionHeaderHopByHopOptions ipv6ExtensionHeader =
                new IpV6ExtensionHeaderHopByHopOptions(IpV4Protocol.IpV6Opts, ipv6options);


            // Define IpV6OptionUnknown
            byte[] buffer = { 0x00, 0x00, 0x00, 0x00 };
            DataSegment dataSegment = new DataSegment(buffer);
            IpV6OptionUnknown optUnknown = new IpV6OptionUnknown((IpV6OptionType)135, dataSegment);

            IpV6Options ipv6options2 = new IpV6Options(optpadN);

            IpV6ExtensionHeaderDestinationOptions ipv6DestinationOptions =
                new IpV6ExtensionHeaderDestinationOptions(IpV4Protocol.FragmentHeaderForIpV6, ipv6options2);


            // Fragment Header
            IpV6ExtensionHeaderFragmentData ipv6ExtensionHeaderFragment =
                new IpV6ExtensionHeaderFragmentData(IpV4Protocol.InternetControlMessageProtocolForIpV6, 0x0000, false, 0x0, 0x00);


            // Test Case
            IpV6ExtensionHeaders ipv6ExtHeads = new IpV6ExtensionHeaders(ipv6ExtensionHeader, ipv6DestinationOptions, ipv6ExtensionHeaderFragment);
            //IpV6ExtensionHeaders ipv6ExtHeads = new IpV6ExtensionHeaders(ipv6DestinationOptions);    //, ipv6ExtensionHeaderFragment);

            ipV6Layer.ExtensionHeaders = ipv6ExtHeads;




            //ipV6Layer.CustomVersion = 0x04;
            uint uintLayerVariable;
            uintLayerVariable = (uiIdentifier << 16) | uiSequence;

            IcmpIpv6UnknownLayer icmpIpv6Layer = new IcmpIpv6UnknownLayer();
            icmpIpv6Layer.LayerMessageType = 0x80;
            icmpIpv6Layer.LayerCode = 0;
            //icmpIpv6Layer.LayerVariable = 0x0001F001;   // Identifier + Sequence = 00 01 00 84 
            icmpIpv6Layer.LayerVariable = uintLayerVariable;
            icmpIpv6Layer.Payload = new Datagram(Encoding.ASCII.GetBytes(strPayload));
            Console.WriteLine("Checksum: " + icmpIpv6Layer.Checksum);
            Log.Info("Checksum: " + icmpIpv6Layer.Checksum);

            PacketBuilder builder = new PacketBuilder(ethernetLayer, ipV6Layer, icmpIpv6Layer);
            Console.WriteLine("Checksum: " + icmpIpv6Layer.Checksum);
            Log.Info("Checksum: " + icmpIpv6Layer.Checksum);

            Packet newPacket = builder.Build(DateTime.Now);

            return newPacket;
        }

        /// <summary>
        /// This function build an IPv6 over Ethernet with payload packet.
        /// </summary>
        protected Packet NewBuildIpV6PacketGroup3FragmentRemoveHopbyhop(UInt32 uiIdentifier, UInt32 uiSequence, byte bVersion, byte bTrafficClass, int nFlowLabel, String strPayload)
        {
            EthernetLayer ethernetLayer =
                new EthernetLayer
                {
                    Source = new MacAddress(sourceMAC), //"00:05:1b:a6:a1:22"),
                    Destination = new MacAddress(destinationMAC),   //"02:00:55:34:02:43"),      // Tracy's UXM
                    EtherType = EthernetType.IpV6,
                };

            // 4, 0, 5, 7, and 15
            // 0011, 0000, 0101, 0111, 1111
            IpV6Layer ipV6Layer =
                new IpV6Layer
                {
                    Source = new IpV6Address(sourceIPv6Address),    //"2001:0:5534:243:3867:41f:7f2a:e625"),    // IPV6 assigned to Laptop from Tracy's UXM router
                    CurrentDestination = new IpV6Address(dutIPv6Address),    //"2001:5:5604:0347:0000:0000:0000:5"),   // DUT's IPV6 assigned from UXM
                    FlowLabel = nFlowLabel,
                    HopLimit = 128,
                    NextHeader = IpV4Protocol.IpV6Opts,    //.IpV6HopByHopOption,
                    CustomVersion = bVersion,
                    TrafficClass = bTrafficClass,
                };

            IpV6OptionPadN optpadN = new IpV6OptionPadN(4);

            IpV6Options ipv6options = new IpV6Options(optpadN);

            IpV6ExtensionHeaderHopByHopOptions ipv6ExtensionHeader =
                new IpV6ExtensionHeaderHopByHopOptions(IpV4Protocol.IpV6Opts, ipv6options);


            // Define IpV6OptionUnknown
            byte[] buffer = { 0x00, 0x00, 0x00, 0x00 };
            DataSegment dataSegment = new DataSegment(buffer);
            IpV6OptionUnknown optUnknown = new IpV6OptionUnknown((IpV6OptionType)135, dataSegment);

            IpV6Options ipv6options2 = new IpV6Options(optpadN);

            IpV6ExtensionHeaderDestinationOptions ipv6DestinationOptions =
                new IpV6ExtensionHeaderDestinationOptions(IpV4Protocol.FragmentHeaderForIpV6, ipv6options2);


            // Fragment Header
            IpV6ExtensionHeaderFragmentData ipv6ExtensionHeaderFragment =
                new IpV6ExtensionHeaderFragmentData(IpV4Protocol.InternetControlMessageProtocolForIpV6, 0x0000, false, 0x0, 0x00);


            // Test Case
            //IpV6ExtensionHeaders ipv6ExtHeads = new IpV6ExtensionHeaders(ipv6ExtensionHeader, ipv6DestinationOptions, ipv6ExtensionHeaderFragment);
            IpV6ExtensionHeaders ipv6ExtHeads = new IpV6ExtensionHeaders(ipv6DestinationOptions, ipv6ExtensionHeaderFragment);

            ipV6Layer.ExtensionHeaders = ipv6ExtHeads;




            //ipV6Layer.CustomVersion = 0x04;
            uint uintLayerVariable;
            uintLayerVariable = (uiIdentifier << 16) | uiSequence;

            IcmpIpv6UnknownLayer icmpIpv6Layer = new IcmpIpv6UnknownLayer();
            icmpIpv6Layer.LayerMessageType = 0x80;
            icmpIpv6Layer.LayerCode = 0;
            //icmpIpv6Layer.LayerVariable = 0x0001F001;   // Identifier + Sequence = 00 01 00 84 
            icmpIpv6Layer.LayerVariable = uintLayerVariable;
            icmpIpv6Layer.Payload = new Datagram(Encoding.ASCII.GetBytes(strPayload));
            Console.WriteLine("Checksum: " + icmpIpv6Layer.Checksum);
            Log.Info("Checksum: " + icmpIpv6Layer.Checksum);

            PacketBuilder builder = new PacketBuilder(ethernetLayer, ipV6Layer, icmpIpv6Layer);
            Console.WriteLine("Checksum: " + icmpIpv6Layer.Checksum);
            Log.Info("Checksum: " + icmpIpv6Layer.Checksum);

            Packet newPacket = builder.Build(DateTime.Now);

            return newPacket;
        }

        /// <summary>
        /// This function build an IPv6 over Ethernet with payload packet.
        /// </summary>
        protected Packet NewBuildIpV6PacketGroup3FragmentRemoveDestination(UInt32 uiIdentifier, UInt32 uiSequence, byte bVersion, byte bTrafficClass, int nFlowLabel, String strPayload)
        {
            EthernetLayer ethernetLayer =
                new EthernetLayer
                {
                    Source = new MacAddress(sourceMAC), //"00:05:1b:a6:a1:22"),
                    Destination = new MacAddress(destinationMAC),   //"02:00:55:34:02:43"),      // Tracy's UXM
                    EtherType = EthernetType.IpV6,
                };

            // 4, 0, 5, 7, and 15
            // 0011, 0000, 0101, 0111, 1111
            IpV6Layer ipV6Layer =
                new IpV6Layer
                {
                    Source = new IpV6Address(sourceIPv6Address),    //"2001:0:5534:243:3867:41f:7f2a:e625"),    // IPV6 assigned to Laptop from Tracy's UXM router
                    CurrentDestination = new IpV6Address(dutIPv6Address),    //"2001:5:5604:0347:0000:0000:0000:5"),   // DUT's IPV6 assigned from UXM
                    FlowLabel = nFlowLabel,
                    HopLimit = 128,
                    NextHeader = IpV4Protocol.FragmentHeaderForIpV6,    //.IpV6HopByHopOption,
                    CustomVersion = bVersion,
                    TrafficClass = bTrafficClass,
                };

            IpV6OptionPadN optpadN = new IpV6OptionPadN(4);

            IpV6Options ipv6options = new IpV6Options(optpadN);

            IpV6ExtensionHeaderHopByHopOptions ipv6ExtensionHeader =
                new IpV6ExtensionHeaderHopByHopOptions(IpV4Protocol.IpV6Opts, ipv6options);


            // Define IpV6OptionUnknown
            byte[] buffer = { 0x00, 0x00, 0x00, 0x00 };
            DataSegment dataSegment = new DataSegment(buffer);
            IpV6OptionUnknown optUnknown = new IpV6OptionUnknown((IpV6OptionType)135, dataSegment);

            IpV6Options ipv6options2 = new IpV6Options(optpadN);

            IpV6ExtensionHeaderDestinationOptions ipv6DestinationOptions =
                new IpV6ExtensionHeaderDestinationOptions(IpV4Protocol.FragmentHeaderForIpV6, ipv6options2);


            // Fragment Header
            IpV6ExtensionHeaderFragmentData ipv6ExtensionHeaderFragment =
                new IpV6ExtensionHeaderFragmentData(IpV4Protocol.InternetControlMessageProtocolForIpV6, 0x0000, true, 0x0, 0x00);


            // Test Case
            //IpV6ExtensionHeaders ipv6ExtHeads = new IpV6ExtensionHeaders(ipv6ExtensionHeader, ipv6DestinationOptions, ipv6ExtensionHeaderFragment);
            //IpV6ExtensionHeaders ipv6ExtHeads = new IpV6ExtensionHeaders(ipv6DestinationOptions, ipv6ExtensionHeaderFragment);
            IpV6ExtensionHeaders ipv6ExtHeads = new IpV6ExtensionHeaders(ipv6ExtensionHeaderFragment);

            ipV6Layer.ExtensionHeaders = ipv6ExtHeads;




            //ipV6Layer.CustomVersion = 0x04;
            uint uintLayerVariable;
            uintLayerVariable = (uiIdentifier << 16) | uiSequence;

            IcmpIpv6UnknownLayer icmpIpv6Layer = new IcmpIpv6UnknownLayer();
            icmpIpv6Layer.LayerMessageType = 0x80;
            icmpIpv6Layer.LayerCode = 0;
            //icmpIpv6Layer.LayerVariable = 0x0001F001;   // Identifier + Sequence = 00 01 00 84 
            icmpIpv6Layer.LayerVariable = uintLayerVariable;
            icmpIpv6Layer.Payload = new Datagram(Encoding.ASCII.GetBytes(strPayload));
            Console.WriteLine("Checksum: " + icmpIpv6Layer.Checksum);
            Log.Info("Checksum: " + icmpIpv6Layer.Checksum);

            PacketBuilder builder = new PacketBuilder(ethernetLayer, ipV6Layer, icmpIpv6Layer);
            Console.WriteLine("Checksum: " + icmpIpv6Layer.Checksum);
            Log.Info("Checksum: " + icmpIpv6Layer.Checksum);

            Packet newPacket = builder.Build(DateTime.Now);

            return newPacket;
        }

        /// <summary>
        /// This function build an IPv6 over Ethernet with payload packet.
        /// </summary>
        protected Packet NewBuildIpV6PacketGroup3FragmentHeaderMbit(UInt32 uiIdentifier, UInt32 uiSequence, byte bVersion, byte bTrafficClass, int nFlowLabel, String strPayload)
        {
            EthernetLayer ethernetLayer =
                new EthernetLayer
                {
                    Source = new MacAddress(sourceMAC), //"00:05:1b:a6:a1:22"),
                    Destination = new MacAddress(destinationMAC),   //"02:00:55:34:02:43"),      // Tracy's UXM
                    EtherType = EthernetType.IpV6,
                };

            // 4, 0, 5, 7, and 15
            // 0011, 0000, 0101, 0111, 1111
            IpV6Layer ipV6Layer =
                new IpV6Layer
                {
                    Source = new IpV6Address(sourceIPv6Address),    //"2001:0:5534:243:3867:41f:7f2a:e625"),    // IPV6 assigned to Laptop from Tracy's UXM router
                    CurrentDestination = new IpV6Address(dutIPv6Address),    //"2001:5:5604:0347:0000:0000:0000:5"),   // DUT's IPV6 assigned from UXM
                    FlowLabel = nFlowLabel,
                    HopLimit = 128,
                    NextHeader = IpV4Protocol.FragmentHeaderForIpV6,    //.IpV6HopByHopOption,
                    CustomVersion = bVersion,
                    TrafficClass = bTrafficClass,
                };

            IpV6OptionPadN optpadN = new IpV6OptionPadN(4);

            IpV6Options ipv6options = new IpV6Options(optpadN);

            IpV6ExtensionHeaderHopByHopOptions ipv6ExtensionHeader =
                new IpV6ExtensionHeaderHopByHopOptions(IpV4Protocol.IpV6Opts, ipv6options);


            // Define IpV6OptionUnknown
            byte[] buffer = { 0x00, 0x00, 0x00, 0x00 };
            DataSegment dataSegment = new DataSegment(buffer);
            IpV6OptionUnknown optUnknown = new IpV6OptionUnknown((IpV6OptionType)135, dataSegment);

            IpV6Options ipv6options2 = new IpV6Options(optpadN);

            IpV6ExtensionHeaderDestinationOptions ipv6DestinationOptions =
                new IpV6ExtensionHeaderDestinationOptions(IpV4Protocol.FragmentHeaderForIpV6, ipv6options2);


            // Fragment Header
            IpV6ExtensionHeaderFragmentData ipv6ExtensionHeaderFragment =
                new IpV6ExtensionHeaderFragmentData(IpV4Protocol.InternetControlMessageProtocolForIpV6, 0x0000, true, 0x0, 0x00);


            // Test Case
            //IpV6ExtensionHeaders ipv6ExtHeads = new IpV6ExtensionHeaders(ipv6ExtensionHeader, ipv6DestinationOptions, ipv6ExtensionHeaderFragment);
            //IpV6ExtensionHeaders ipv6ExtHeads = new IpV6ExtensionHeaders(ipv6DestinationOptions, ipv6ExtensionHeaderFragment);
            IpV6ExtensionHeaders ipv6ExtHeads = new IpV6ExtensionHeaders(ipv6ExtensionHeaderFragment);

            ipV6Layer.ExtensionHeaders = ipv6ExtHeads;




            //ipV6Layer.CustomVersion = 0x04;
            uint uintLayerVariable;
            uintLayerVariable = (uiIdentifier << 16) | uiSequence;

            IcmpIpv6UnknownLayer icmpIpv6Layer = new IcmpIpv6UnknownLayer();
            icmpIpv6Layer.LayerMessageType = 0x80;
            icmpIpv6Layer.LayerCode = 0;
            //icmpIpv6Layer.LayerVariable = 0x0001F001;   // Identifier + Sequence = 00 01 00 84 
            icmpIpv6Layer.LayerVariable = uintLayerVariable;
            icmpIpv6Layer.Payload = new Datagram(Encoding.ASCII.GetBytes(strPayload));
            Console.WriteLine("Checksum: " + icmpIpv6Layer.Checksum);
            Log.Info("Checksum: " + icmpIpv6Layer.Checksum);

            PacketBuilder builder = new PacketBuilder(ethernetLayer, ipV6Layer, icmpIpv6Layer);
            Console.WriteLine("Checksum: " + icmpIpv6Layer.Checksum);
            Log.Info("Checksum: " + icmpIpv6Layer.Checksum);

            Packet newPacket = builder.Build(DateTime.Now);

            return newPacket;
        }

        protected Verdict EvaluateResult(String TestName, double LowLimit, double HiLimit, double Meas)
        {
            Verdict retValue = Verdict.Fail;

            limitBar.LowerLimit = LowLimit;
            limitBar.UpperLimit = HiLimit;
            string strLimitBar = limitBar.GetBar(Meas);

            Log.Info("{0,50} : {1,6:0.00} dBm  {2}", TestName, Meas, strLimitBar);

            // Get Verdict
            if ((Meas >= LowLimit) && (Meas <= HiLimit))
            {
                UpgradeVerdict(Verdict.Pass);
                retValue = Keysight.Tap.Verdict.Pass;
            }
            else
            {
                UpgradeVerdict(Verdict.Fail);
                retValue = Keysight.Tap.Verdict.Fail;
            }
            return retValue;
        }

        protected virtual void FormatStepName()
        {
            try
            {
                string newName = GetStepNameFromTypeName(this.TypeName);

                if (this.Name != newName) this.Name = newName;
            }
            catch
            {
                // Ignore error
            }
        }

        // Get Test Step original name
        public string GetStepNameFromTypeName(string typeName)
        {
            int index = 0;

            index = typeName.LastIndexOf("\\");
            if (index > 0 && index < typeName.Length)
            {
                return typeName.Substring(index + 1).Trim();
            }
            else
            {
                return typeName;
            }
        }

        protected int ValidateEchoReceived(int nPacketCount)
        {
            int nStatus = -1;
            if (nPacketCount >= 1)
            {
                // Reply was received
                // PASS
                nStatus = 0;
            }
            else
            {
                // Fail!
                nStatus = -2;
            }
            return nStatus;
        }

        protected int ValidateNoReply(int nPacketCount)
        {
            int nStatus = -1;
            if (nPacketCount == 1)
            {
                // No Reply was received
                // PASS
                nStatus = 0;
            }
            else if (nPacketCount > 1)
            {
                // Some response was received
                // FAIL
                nStatus = -2;
            }
            else
            {
                // Some other failure
                // Fail!
                nStatus = -3;
            }
            return nStatus;
        }

        protected int ValidatePingReplyReceived(int nPacketCount, Packet lastPacket)
        {
            Log.Info("ValidatePingReplyReceived()");
            Log.Info("nPacketCount:" + nPacketCount.ToString());
            if (lastPacket == null)
            {
                Log.Info("lastPacket: null");
            }
            else
            {
                Log.Info("lastPacket:" + lastPacket.ToString());
            }

            int nStatus = -1;
            if (nPacketCount <= 1)
            {
                // Only one packet was received
                // most likely an echo request
                Log.Info("Only one packet was received\n nStatus = -2");
                nStatus = -2;
            }
            else
            {
                if (lastPacket == null)
                {
                    // Last Packet does not exist
                    nStatus = -98;
                    Log.Info("Last Packet does not exist\n nStatus = -98");
                    return nStatus;
                }

                // More than one packet received, lets verify content of last packet
                Datagram icmpv6Datagram = lastPacket.Ethernet.IpV6.Payload;
                String udpHexString = icmpv6Datagram.ToHexadecimalString();
                Log.Info("icmpv6Datagram: " + icmpv6Datagram.ToString());
                Log.Info("udpHexString: " + udpHexString.ToString());

                String icmpv6Type = udpHexString.Substring(0, 1 * 2);
                String icmpv6Code = udpHexString.Substring(2, 1 * 2);
                String icmpv6Checksum = udpHexString.Substring(4, 2 * 2);
                String icmpv6Identifier = udpHexString.Substring(8, 2 * 2);
                String icmpv6Sequence = udpHexString.Substring(12, 2 * 2);
                Log.Info("icmpv6Type: " + icmpv6Type.ToString());
                Log.Info("icmpv6Code: " + icmpv6Code.ToString());
                Log.Info("icmpv6Checksum: " + icmpv6Checksum.ToString());
                Log.Info("icmpv6Identifier: " + icmpv6Identifier.ToString());
                Log.Info("icmpv6Sequence: " + icmpv6Sequence.ToString());

                int nIcmpv6Type = Convert.ToUInt16(icmpv6Type, 16);
                int nIcmpv6Code = Convert.ToUInt16(icmpv6Code, 16);
                int nIcmpv6Identifier = Convert.ToUInt16(icmpv6Identifier, 16);
                int nIcmpv6Sequence = Convert.ToUInt16(icmpv6Sequence, 16);
                Log.Info("nIcmpv6Type: " + nIcmpv6Type.ToString());
                Log.Info("nIcmpv6Code: " + nIcmpv6Code.ToString());
                Log.Info("nIcmpv6Identifier: " + nIcmpv6Identifier.ToString());
                Log.Info("nIcmpv6Sequence: " + nIcmpv6Sequence.ToString());

                //  Echo (ping) reply (129)
                if (nIcmpv6Type == 129)
                {
                    // Valid ping reply!
                    // PASS!
                    nStatus = 0;
                }
                else
                {
                    // Not a ping request or reply
                    nStatus = -3;
                }
            }
            Log.Info("ValidatePingReplyReceived->nStatus: " + nStatus.ToString());
            return nStatus;
        }

        public  int ValidateParameterProblemReceived(int nPacketCount, Packet lastPacket)
        {
            Log.Info("ValidateParameterProblemReceived()");
            Log.Info("nPacketCount: " + nPacketCount.ToString());
            if (lastPacket == null)
            {
                Log.Info("lastPacket: null");
            }
            else
            {
                Log.Info("lastPacket:" + lastPacket.ToString());
            }

            int nStatus = -1;
            if (nPacketCount <= 1)
            {
                // Only one packet was received
                // most likely an echo request
                nStatus = -2;
                Log.Info("Only one packet was received\n nStatus = -2");
            }
            else
            {
                if (lastPacket == null)
                {
                    // Last Packet does not exist
                    nStatus = -99;
                    Log.Info("Last Packet does not exist\n nStatus = -99");
                    return nStatus;
                }

                // More than one packet received, lets verify content of last packet
                // It should be the parameter problem
                Datagram icmpv6Datagram = lastPacket.Ethernet.IpV6.Payload;
                String udpHexString = icmpv6Datagram.ToHexadecimalString();
                Log.Info("icmpv6Datagram: " + icmpv6Datagram.ToString());
                Log.Info("udpHexString: " + udpHexString.ToString());

                String icmpv6Type = udpHexString.Substring(0, 1 * 2);
                String icmpv6Code = udpHexString.Substring(2, 1 * 2);
                String icmpv6Checksum = udpHexString.Substring(4, 2 * 2);
                String icmpv6Identifier = udpHexString.Substring(8, 2 * 2);
                String icmpv6Sequence = udpHexString.Substring(12, 2 * 2);
                String icmpv6Pointer = udpHexString.Substring(8, 4 * 2);
                Log.Info("icmpv6Type: " + icmpv6Type.ToString());
                Log.Info("icmpv6Code: " + icmpv6Code.ToString());
                Log.Info("icmpv6Checksum: " + icmpv6Checksum.ToString());
                Log.Info("icmpv6Identifier: " + icmpv6Identifier.ToString());
                Log.Info("icmpv6Sequence: " + icmpv6Sequence.ToString());
                Log.Info("icmpv6Pointer: " + icmpv6Pointer.ToString());

                int nIcmpv6Type = Convert.ToUInt16(icmpv6Type, 16);
                int nIcmpv6Code = Convert.ToUInt16(icmpv6Code, 16);
                int nIcmpv6Identifier = Convert.ToUInt16(icmpv6Identifier, 16);
                int nIcmpv6Sequence = Convert.ToUInt16(icmpv6Sequence, 16);
                int nIcmpv6Pointer = Convert.ToUInt16(icmpv6Pointer, 16);
                Log.Info("nIcmpv6Type: " + nIcmpv6Type.ToString());
                Log.Info("nIcmpv6Code: " + nIcmpv6Code.ToString());
                Log.Info("nIcmpv6Identifier: " + nIcmpv6Identifier.ToString());
                Log.Info("nIcmpv6Sequence: " + nIcmpv6Sequence.ToString());
                Log.Info("nIcmpv6Pointer: " + nIcmpv6Pointer.ToString());

                //  Echo (ping) reply (129)
                // Time Exceeded Message (3)
                // Parameter Problem (4)
                if (nIcmpv6Type == 3)
                {
                    // Time Exceeded
                    if (nIcmpv6Code == 1)
                    {
                        // 1.3.2
                        // Code 1

                        // PASS!
                        nStatus = 0;
                    }
                    else
                    {
                        // Faile
                        nStatus = -5;
                    }
                }
                else if (nIcmpv6Type == 4)
                {
                    // Parameter Problem!
                    // Now lets verify the pointer
                    if ((nIcmpv6Code == 0) && (nIcmpv6Pointer == 4))
                    {
                        // 1.3.3
                        // Code 0
                        // Offset 4

                        // PASS!
                        nStatus = 0;
                    }
                    else if ((nIcmpv6Code == 1) && (nIcmpv6Pointer == 0x28))
                    {
                        // 1.2.1 and 1.2.3
                        // Code 1
                        // Offset 28

                        // PASS!
                        nStatus = 0;
                    }
                    else if ((nIcmpv6Code == 2) && (nIcmpv6Pointer == 0x32))
                    {
                        // 1.2.4
                        // Code 2
                        // Offset 28

                        // PASS!
                        nStatus = 0;
                    }
                    else if ((nIcmpv6Code == 2) && (nIcmpv6Pointer == 0x30))
                    {
                        // 1.2.5
                        // Code 2
                        // Offset 30

                        // PASS!
                        nStatus = 0;
                    }
                    else if ((nIcmpv6Code == 2) && (nIcmpv6Pointer == 0x2A))
                    {
                        // 1.2.8
                        // Code 2
                        // Offset 2A

                        // PASS!
                        nStatus = 0;
                    }
                    else
                    {
                        // Faile
                        nStatus = -4;
                    }
                }
                else
                {
                    // Not a parameter problem type
                    nStatus = -3;
                }
            }
            Log.Info("ValidateParameterProblemReceived->nStatus: " + nStatus.ToString());
            return nStatus;
        }

        protected void EvaluateParameterProblem(UNRECOGNIZED_NEXT_HEADER_VALIDATE_REPLY ValidateValue, 
            Verdict PingRequestReceivedStatus,
            int nPacketCount,
            ref Verdict ParameterProblemStatus,
            Packet lastPacketParameterProblem) 
        {
            Log.Info("EvaluateParameterProblem");
            Log.Info("ValidateValue: " + ValidateValue.ToString());
            Log.Info("PingRequestReceivedStatus: " + PingRequestReceivedStatus.ToString());
            Log.Info("nPacketCount: " + nPacketCount.ToString());
            if (lastPacketParameterProblem == null)
            {
                Log.Info("lastPacketParameterProblem: null");
            }
            else
            {
                Log.Info("lastPacketParameterProblem:" + lastPacketParameterProblem.ToString());
            }

            // Validate ICMPv6 Parameter Problem
            int nParameterProblemStatus = -1;
            switch (ValidateValue)
            {
                case UNRECOGNIZED_NEXT_HEADER_VALIDATE_REPLY.UNRECOGNIZED_NEXT_HEADER:
                    // if last packet is unrecognized next header
                    if ((PingRequestReceivedStatus == Keysight.Tap.Verdict.Pass) &&
                        (nPacketCount > 1))
                    {
                        nParameterProblemStatus = ValidateParameterProblemReceived(nPacketCount, lastPacketParameterProblem);
                        // Publish Results
                        Results.Publish("Main Results", new
                            List<string> { "Test Name", "LSL", "USL", "Measurement" },
                            new IConvertible[] { this.Name + "_ParameterProblemStatus_Received", 0, 1, nParameterProblemStatus });
                        ParameterProblemStatus = EvaluateResult(this.Name + "_ParameterProblemStatus_Received", 0, 1, nParameterProblemStatus);
                    }
                    else
                    {
                        nParameterProblemStatus = -11;
                        // Publish Results
                        Results.Publish("Main Results", new
                            List<string> { "Test Name", "LSL", "USL", "Measurement" },
                            new IConvertible[] { this.Name + "_ParameterProblemStatus_Received", 0, 1, nParameterProblemStatus });
                        ParameterProblemStatus = EvaluateResult(this.Name + "_ParameterProblemStatus_Received", 0, 1, nParameterProblemStatus);
                    }
                    break;
                case UNRECOGNIZED_NEXT_HEADER_VALIDATE_REPLY.NO_REPLY:
                    // Validate lastPacketParameterProblem is null
                    // this means that the pcap library didn't find any parameter problem packets
                    if (lastPacketParameterProblem == null)
                    {
                        // PASS
                        nParameterProblemStatus = 0;
                        // Publish Results
                        Results.Publish("Main Results", new
                            List<string> { "Test Name", "LSL", "USL", "Measurement" },
                            new IConvertible[] { this.Name + "_ParameterProblemStatus_Received", 0, 1, nParameterProblemStatus });
                        ParameterProblemStatus = EvaluateResult(this.Name + "_ParameterProblemStatus_Received", 0, 1, nParameterProblemStatus);
                    }
                    else
                    {
                        // FAil
                        nParameterProblemStatus = -12;
                        // Publish Results
                        Results.Publish("Main Results", new
                            List<string> { "Test Name", "LSL", "USL", "Measurement" },
                            new IConvertible[] { this.Name + "_ParameterProblemStatus_Received", 0, 1, nParameterProblemStatus });
                        ParameterProblemStatus = EvaluateResult(this.Name + "_ParameterProblemStatus_Received", 0, 1, nParameterProblemStatus);
                    }
                    break;
            }

        }

        protected void EvaluateTimeExceeded(TIME_EXCEEDED_VALIDATE_REPLY ValidateValue,
                        Verdict PingRequestReceivedStatus,
                        int nPacketCount,
                        ref Verdict ParameterProblemStatus,
                        Packet lastPacketParameterProblem,
                        String AdditionalTestName = "")
        {
            // Validate ICMPv6 Parameter Problem
            int nParameterProblemStatus = -1;
            switch (ValidateValue)
            {
                case TIME_EXCEEDED_VALIDATE_REPLY.TIME_EXCEEDED:
                    // if last packet is unrecognized next header
                    if ((PingRequestReceivedStatus == Keysight.Tap.Verdict.Pass) &&
                        (nPacketCount > 1))
                    {
                        nParameterProblemStatus = ValidateParameterProblemReceived(nPacketCount, lastPacketParameterProblem);
                        // Publish Results
                        Results.Publish("Main Results", new
                            List<string> { "Test Name", "LSL", "USL", "Measurement" },
                            new IConvertible[] { this.Name + "_TimeExceeded_Received" + AdditionalTestName, 0, 1, nParameterProblemStatus });
                        ParameterProblemStatus = EvaluateResult(this.Name + "_TimeExceeded_Received" + AdditionalTestName, 0, 1, nParameterProblemStatus);
                    }
                    else
                    {
                        nParameterProblemStatus = -11;
                        // Publish Results
                        Results.Publish("Main Results", new
                            List<string> { "Test Name", "LSL", "USL", "Measurement" },
                            new IConvertible[] { this.Name + "_TimeExceeded_Received" + AdditionalTestName, 0, 1, nParameterProblemStatus });
                        ParameterProblemStatus = EvaluateResult(this.Name + "_TimeExceeded_Received" + AdditionalTestName, 0, 1, nParameterProblemStatus);
                    }
                    break;
                case TIME_EXCEEDED_VALIDATE_REPLY.NO_REPLY:
                    // Validate lastPacketParameterProblem is null
                    // this means that the pcap library didn't find any parameter problem packets
                    if (lastPacketParameterProblem == null)
                    {
                        // PASS
                        nParameterProblemStatus = 0;
                        // Publish Results
                        Results.Publish("Main Results", new
                            List<string> { "Test Name", "LSL", "USL", "Measurement" },
                            new IConvertible[] { this.Name + "_TimeExceeded_Received" + AdditionalTestName, 0, 1, nParameterProblemStatus });
                        ParameterProblemStatus = EvaluateResult(this.Name + "_TimeExceeded_Received" + AdditionalTestName, 0, 1, nParameterProblemStatus);
                    }
                    else
                    {
                        // FAil
                        nParameterProblemStatus = -12;
                        // Publish Results
                        Results.Publish("Main Results", new
                            List<string> { "Test Name", "LSL", "USL", "Measurement" },
                            new IConvertible[] { this.Name + "_TimeExceeded_Received" + AdditionalTestName, 0, 1, nParameterProblemStatus });
                        ParameterProblemStatus = EvaluateResult(this.Name + "_TimeExceeded_Received" + AdditionalTestName, 0, 1, nParameterProblemStatus);
                    }
                    break;
            }

        }

        protected void EvaluatePingReply(PING_REPLY_VALIDATE ValidateValue, 
            Verdict PingRequestReceivedStatus,
            int nPacketCount,
            ref Verdict PingReplyReceivedStatus,
            Packet lastPacket,
            String AdditionalResultName = "")
        {
            Log.Info("EvaluatePingReply()");
            Log.Info("ValidateValue:" + ValidateValue.ToString());
            Log.Info("PingRequestReceivedStatus:" + PingRequestReceivedStatus.ToString());
            Log.Info("nPacketCount:" + nPacketCount.ToString());
            if (lastPacket == null)
            {
                Log.Info("lastPacket: null");
            }
            else
            {
                Log.Info("lastPacket:" + lastPacket.ToString());
            }

            int nPingReplyReceivedStatus = -1;
            switch (ValidateValue)
            {
                case PING_REPLY_VALIDATE.PING_REPLY:
                    // if last packet is ping reply
                    if ((PingRequestReceivedStatus == Keysight.Tap.Verdict.Pass) &&
                        (nPacketCount >= 1))
                    {
                        nPingReplyReceivedStatus = ValidatePingReplyReceived(nPacketCount, lastPacket);
                        // Publish Results
                        Results.Publish("Main Results", new
                            List<string> { "Test Name", "LSL", "USL", "Measurement" },
                            new IConvertible[] { this.Name + "nPingReplyReceivedStatus" + AdditionalResultName, 0, 1, nPingReplyReceivedStatus });
                        PingReplyReceivedStatus = EvaluateResult(this.Name + "nPingReplyReceivedStatus" + AdditionalResultName, 0, 1, nPingReplyReceivedStatus);
                    }
                    else
                    {
                        nPingReplyReceivedStatus = -12;
                        // Publish Results
                        Results.Publish("Main Results", new
                            List<string> { "Test Name", "LSL", "USL", "Measurement" },
                            new IConvertible[] { this.Name + "nPingReplyReceivedStatus" + AdditionalResultName, 0, 1, nPingReplyReceivedStatus });
                        PingReplyReceivedStatus = EvaluateResult(this.Name + "nPingReplyReceivedStatus" + AdditionalResultName, 0, 1, nPingReplyReceivedStatus);
                    }
                    break;
                case PING_REPLY_VALIDATE.NO_REPLY:
                    if (PingRequestReceivedStatus == Keysight.Tap.Verdict.Pass)
                    {
                        // Validate last packet is not a ping reply
                        if (ValidatePingReplyReceived(nPacketCount, lastPacket) != 0)
                        { 
                            // Last packet was not a valid ping reply
                            // Success!
                            nPingReplyReceivedStatus = 0;
                        }
                        else
                        {
                            nPingReplyReceivedStatus = -11;
                        }

                        // Publish Results
                        Results.Publish("Main Results", new
                            List<string> { "Test Name", "LSL", "USL", "Measurement" },
                            new IConvertible[] { this.Name + "NoReply" + AdditionalResultName, 0, 1, nPingReplyReceivedStatus });
                        PingReplyReceivedStatus = EvaluateResult(this.Name + "NoReply" + AdditionalResultName, 0, 1, nPingReplyReceivedStatus);
                    }
                    else
                    {
                        nPingReplyReceivedStatus = -10;
                        // Publish Results
                        Results.Publish("Main Results", new
                            List<string> { "Test Name", "LSL", "USL", "Measurement" },
                            new IConvertible[] { this.Name + "NoReply" + AdditionalResultName, 0, 1, nPingReplyReceivedStatus });
                        PingReplyReceivedStatus = EvaluateResult(this.Name + "NoReply" + AdditionalResultName, 0, 1, nPingReplyReceivedStatus);
                    }
                    break;
            }
        }

    }
}
