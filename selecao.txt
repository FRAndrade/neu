// Author: MyName
// Copyright:   Copyright 2017 Keysight Technologies
//              You have a royalty-free right to use, modify, reproduce and distribute
//              the sample application files (and/or any modified version) in any way
//              you find useful, provided that you agree that Keysight Technologies has no
//              warranty, obligations or liability for any sample application files.
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ComponentModel;
using System.Text.RegularExpressions;

using Keysight.Tap;  // Use Platform infrastructure/core components (log,TestStep definition, etc)
using PcapDotNet.Base;
using PcapDotNet.Core;
using PcapDotNet.Packets;
using PcapDotNet.Packets.Arp;
using PcapDotNet.Packets.Dns;
using PcapDotNet.Packets.Ethernet;
using PcapDotNet.Packets.Gre;
using PcapDotNet.Packets.Http;
using PcapDotNet.Packets.Icmp;
using PcapDotNet.Packets.Igmp;
using PcapDotNet.Packets.IpV4;
using PcapDotNet.Packets.IpV6;
using PcapDotNet.Packets.Transport;
using System.Threading;

namespace Tap.Plugins.Anatel_IPv6_Test
{
    public enum NEXT_HEADER_ZERO_VALIDATE_REPLY
    {
        UNRECOGNIZED_NEXT_HEADER = 0,
        PING_REPLY = 1,
        UNRECOGNIZED_NEXT_HEADER_AND_PING_REPLY = 2,
        NO_REPLY
    }

    [Display("V6LC.1.2.1 Next Header Zero", Group: "Anatel_IPv6_Test", Description: "Insert description here")]
    public class V6LC_1_2_1_NextHeaderZero : V6LC_BaseTest
    {
        #region Settings
        [Display("Validate Next Header Zero Reply", Group: "Limits", Order: 4.4, Description: "Validate Next Header Zero Reply")]
        public NEXT_HEADER_ZERO_VALIDATE_REPLY NextHeaderZeroValidate { get; set; }

        #endregion

        public V6LC_1_2_1_NextHeaderZero()
            : base()
        {
            // Show Validate options on GUI
            showValidateEchoRequest = true;
            showValidateEchoReply = false;

            // Validate options for this test
            validateEchoRequest = YesNo.Yes;
            validateEchoReply = YesNo.Yes;

            // Expected Test Case result
            NextHeaderZeroValidate = NEXT_HEADER_ZERO_VALIDATE_REPLY.UNRECOGNIZED_NEXT_HEADER;

            FormatStepName();
        }

        /// <summary>
        /// Procedure:
        /// 1. TN1 transmits Packet A to the NUT, which has a Hop-by-Hop Options header with a Next
        /// Header field of zero.
        /// 2. Observe the packets transmitted by the NUT.
        /// 
        /// Observable Results:
        /// 1. The NUT should send an ICMPv6 Parameter Problem message to TN1. The ICMPv6 Code
        /// field should be 1 (unrecognized Next Header type encountered). The ICMPv6 Pointer field should be
        /// 0x28 (offset of the Next Header field of the Hop-by-Hop Options header). 
        /// 2. The NUT should discard the Echo Request and not send an Echo Reply to TN1.
        /// </summary>
        public override void Run()
        {
            CommonTestInit();

            Verdict PingRequestReceivedStatus = Keysight.Tap.Verdict.NotSet;
            Verdict PingReplyReceivedStatus = Keysight.Tap.Verdict.NotSet;
            Verdict ParameterProblemStatus = Keysight.Tap.Verdict.NotSet;

            // Retrieve the device list from the local machine
            IList<LivePacketDevice> allDevices = LivePacketDevice.AllLocalMachine;

            if (allDevices.Count == 0)
            {
                Log.Info("No interfaces found! Make sure WinPcap is installed.");
                return;
            }

            // Print the list
            for (int i = 0; i != allDevices.Count; ++i)
            {
                LivePacketDevice device = allDevices[i];
                Log.Info((i + 1) + ". " + device.Name);
                if (device.Description != null)
                    Log.Info(" (" + device.Description + ")");
                else
                    Log.Info(" (No description available)");
            }

            // Interface Index
            int deviceIndex = nicId;

            // Take the selected adapter
            PacketDevice selectedDevice = allDevices[deviceIndex - 1];

            // Open the output device
            using (PacketCommunicator communicator = selectedDevice.Open(100, // name of the device
                                                                         PacketDeviceOpenAttributes.Promiscuous, // promiscuous mode
                                                                         1000)) // read timeout
            {
                // Transmit Packet
                uintSequenceNumber++;
                byte bVer = (byte)Byte.Parse("6");
                byte bTrafficClass = 0;
                int nFlowLabel = (int)int.Parse("0");

                String TapFolder = System.IO.Path.GetDirectoryName(System.Windows.Forms.Application.ExecutablePath);
                String startTime = PlanRun.StartTime.ToString("yyyy-MM-dd-HH-mm-ss-");
                String logFileName = TapFolder + @"\Results\" + startTime + this.GetType().Name;
                // Start Packet Capture
                PcapCapturePackets packetCapture = new PcapCapturePackets(Log, nicId, sourceMAC, destinationMAC, sourceIPv6Address, dutIPv6Address, logFileName);
                // Make sure Packet Capture has started before sending ping request
                Thread.Sleep(1000);

                // Ping request
                communicator.SendPacket(NewBuildIpV6PacketGroup2NextHeaderZero(uintIdentifier, uintSequenceNumber, bVer, bTrafficClass, nFlowLabel, "abcdefghijklmnopqrstuvwabcdefghi", IpV4Protocol.IpV6HopByHopOption));

                // Wait
                Log.Info("Run()->Sleep");
                int nRetry = 0;
                do
                {
                    // Wait until we have received echo and reply
                    Thread.Sleep(1000);
                } while (nRetry++ < 10);

                // Validate Received echo
                Console.WriteLine("Packets Received: " + packetCapture.PacketCounter);

                // Terminate capture packets
                Packet lastPacket = packetCapture.LastPacket;
                Packet lastPacketParameterProblem = packetCapture.LastPacketParameterProblem;
                int nPacketCount = packetCapture.PacketCounter;

                // Validate Test Case
                // Validate Echo reply was received0
                int nEchoReplyReceivedStatus = -1;
                nEchoReplyReceivedStatus = ValidateEchoReceived(nPacketCount);
                // Publish Results
                Results.Publish("Main Results", new
                    List<string> { "Test Name", "LSL", "USL", "Measurement" },
                    new IConvertible[] { this.Name + "_Ping_Request_Received", 0, 1, nEchoReplyReceivedStatus });
                PingRequestReceivedStatus = EvaluateResult(this.Name + "_Ping_Request_Received", 0, 1, nEchoReplyReceivedStatus);

                int nPingReplyReceivedStatus = -1;
                // Packets received should be:
                //      1: Only Echo Ping Request received - FAIL
                //      2: Ping Reply from DUT - FAIL
                //      2: Parameter Problem from DUT - PASS
                //      3: Ping Reply from DUT and Parameter Problem - FAIL
                switch (NextHeaderZeroValidate)
                {
                    case NEXT_HEADER_ZERO_VALIDATE_REPLY.UNRECOGNIZED_NEXT_HEADER:
                        // if last packet is unrecognized next header
                        if ((PingRequestReceivedStatus == Keysight.Tap.Verdict.Pass) &&
                            (nPacketCount > 1))
                        {
                            nPingReplyReceivedStatus = ValidateParameterProblemReceived(nPacketCount, lastPacketParameterProblem);
                            // Publish Results
                            Results.Publish("Main Results", new
                                List<string> { "Test Name", "LSL", "USL", "Measurement" },
                                new IConvertible[] { this.Name + "_ParameterProblemStatus_Received", 0, 1, nPingReplyReceivedStatus });
                            ParameterProblemStatus = EvaluateResult(this.Name + "_ParameterProblemStatus_Received", 0, 1, nPingReplyReceivedStatus);

                            // Set Ping reply status to pass
                            PingReplyReceivedStatus = Keysight.Tap.Verdict.Pass;
                        }
                        else
                        {
                            nPingReplyReceivedStatus = -11;
                            // Publish Results
                            Results.Publish("Main Results", new
                                List<string> { "Test Name", "LSL", "USL", "Measurement" },
                                new IConvertible[] { this.Name + "_ParameterProblemStatus_Received", 0, 1, nPingReplyReceivedStatus });
                            ParameterProblemStatus = EvaluateResult(this.Name + "_ParameterProblemStatus_Received", 0, 1, nPingReplyReceivedStatus);

                            PingReplyReceivedStatus = Keysight.Tap.Verdict.Fail;
                            ParameterProblemStatus = Keysight.Tap.Verdict.Fail;
                        }
                        break;
                    case NEXT_HEADER_ZERO_VALIDATE_REPLY.PING_REPLY:
                        // if last packet is ping reply
                        if ((PingRequestReceivedStatus == Keysight.Tap.Verdict.Pass) &&
                            (nPacketCount > 1))
                        {
                            nPingReplyReceivedStatus = ValidatePingReplyReceived(nPacketCount, lastPacket);
                            // Publish Results
                            Results.Publish("Main Results", new
                                List<string> { "Test Name", "LSL", "USL", "Measurement" },
                                new IConvertible[] { this.Name + "nPingReplyReceivedStatus", 0, 1, nPingReplyReceivedStatus });
                            PingReplyReceivedStatus = EvaluateResult(this.Name + "nPingReplyReceivedStatus", 0, 1, nPingReplyReceivedStatus);

                            // Set Ping reply status to pass
                            ParameterProblemStatus = Keysight.Tap.Verdict.Pass;
                        }
                        else
                        {
                            nPingReplyReceivedStatus = -12;
                            // Publish Results
                            Results.Publish("Main Results", new
                                List<string> { "Test Name", "LSL", "USL", "Measurement" },
                                new IConvertible[] { this.Name + "nPingReplyReceivedStatus", 0, 1, nPingReplyReceivedStatus });
                            PingReplyReceivedStatus = EvaluateResult(this.Name + "nPingReplyReceivedStatus", 0, 1, nPingReplyReceivedStatus);

                            PingReplyReceivedStatus = Keysight.Tap.Verdict.Fail;
                            ParameterProblemStatus = Keysight.Tap.Verdict.Fail;
                        }
                        break;
                    case NEXT_HEADER_ZERO_VALIDATE_REPLY.UNRECOGNIZED_NEXT_HEADER_AND_PING_REPLY:
                        // validate two packets have been received
                        {
                            // TODO
                            // Fail for now
                            PingReplyReceivedStatus = Keysight.Tap.Verdict.Fail;
                            ParameterProblemStatus = Keysight.Tap.Verdict.Fail;
                        }
                        break;
                    case NEXT_HEADER_ZERO_VALIDATE_REPLY.NO_REPLY:
                        if ((PingRequestReceivedStatus == Keysight.Tap.Verdict.Pass) && 
                            (nPacketCount <=1))
                        {
                            nPingReplyReceivedStatus = 0;
                            // Publish Results
                            Results.Publish("Main Results", new
                                List<string> { "Test Name", "LSL", "USL", "Measurement" },
                                new IConvertible[] { this.Name + "NoReply", 0, 1, nPingReplyReceivedStatus });
                            PingReplyReceivedStatus = EvaluateResult(this.Name + "NoReply", 0, 1, nPingReplyReceivedStatus);

                            // Only Echo Ping Request has been received
                            PingReplyReceivedStatus = Keysight.Tap.Verdict.Pass;
                            ParameterProblemStatus = Keysight.Tap.Verdict.Pass;
                        }
                        else
                        {
                            nPingReplyReceivedStatus = -10;
                            // Publish Results
                            Results.Publish("Main Results", new
                                List<string> { "Test Name", "LSL", "USL", "Measurement" },
                                new IConvertible[] { this.Name + "NoReply", 0, 1, nPingReplyReceivedStatus });
                            PingReplyReceivedStatus = EvaluateResult(this.Name + "NoReply", 0, 1, nPingReplyReceivedStatus);

                            // Ping request failed or more than one packet received
                            PingReplyReceivedStatus = Keysight.Tap.Verdict.Fail;
                            ParameterProblemStatus = Keysight.Tap.Verdict.Fail;
                        }
                        break;
                }

                // Test cleanup
                CommonTestCleanup(communicator, packetCapture);
            }

            // Update verdict to pass only if PER and RSSI have passed
            if ((PingRequestReceivedStatus == Keysight.Tap.Verdict.Pass) &&
                (PingReplyReceivedStatus == Keysight.Tap.Verdict.Pass) &&
                (ParameterProblemStatus == Keysight.Tap.Verdict.Pass))
            {
                UpgradeVerdict(Verdict.Pass);
            }
            else
            {
                UpgradeVerdict(Verdict.Fail);
            }
        }

    }
}
