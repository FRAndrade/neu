// Author: MyName
// Copyright:   Copyright 2017 Keysight Technologies
//              You have a royalty-free right to use, modify, reproduce and distribute
//              the sample application files (and/or any modified version) in any way
//              you find useful, provided that you agree that Keysight Technologies has no
//              warranty, obligations or liability for any sample application files.
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ComponentModel;
using System.Text.RegularExpressions;

using Keysight.Tap;  // Use Platform infrastructure/core components (log,TestStep definition, etc)
using PcapDotNet.Base;
using PcapDotNet.Core;
using PcapDotNet.Packets;
using PcapDotNet.Packets.Arp;
using PcapDotNet.Packets.Dns;
using PcapDotNet.Packets.Ethernet;
using PcapDotNet.Packets.Gre;
using PcapDotNet.Packets.Http;
using PcapDotNet.Packets.Icmp;
using PcapDotNet.Packets.Igmp;
using PcapDotNet.Packets.IpV4;
using PcapDotNet.Packets.IpV6;
using PcapDotNet.Packets.Transport;
using System.Threading;

namespace Tap.Plugins.Anatel_IPv6_Test
{
    public enum UNRECOGNIZED_NEXT_HEADER_VALIDATE_REPLY
    {
        UNRECOGNIZED_NEXT_HEADER = 0,
        NO_REPLY
    }

    public enum PING_REPLY_VALIDATE
    {
        PING_REPLY = 0,
        NO_REPLY
    }

    [Display("V6LC.1.2.3_UnrecognizedNextHeader", Group: "Anatel_IPv6_Test", Description: "Insert description here")]
    public class V6LC_1_2_3_UnrecognizedNextHeader : V6LC_BaseTest
    {
        #region Settings
        [Display("Validate Unrecognized Next Header Reply", Group: "Limits - Part A", Order: 4.4, Description: "Validate Unrecognized Next Header Reply")]
        public UNRECOGNIZED_NEXT_HEADER_VALIDATE_REPLY PartAUnrecognizedNextHeaderValidate { get; set; }

        [Display("Validate Ping Reply", Group: "Limits - Part A", Order: 4.5, Description: "Validate Ping Reply")]
        public PING_REPLY_VALIDATE PartAPingReplyValidate { get; set; }

        [Display("Unrecognized Next Header Start", Group: "Limits - Part A", Order: 4.6, Description: "Unrecognized Next Header value Start")]
        public int FirstUnrecognizedHeader { get; set; }

        [Display("Unrecognized Next Header Finish", Group: "Limits - Part A", Order: 4.7, Description: "Unrecognized Next Header value Finish")]
        public int LastUnrecognizedHeader { get; set; }

        [Display("Validate Unrecognized Next Header Reply", Group: "Limits - Part B", Order: 5.4, Description: "Validate Unrecognized Next Header Reply")]
        public UNRECOGNIZED_NEXT_HEADER_VALIDATE_REPLY PartBUnrecognizedNextHeaderValidate { get; set; }

        [Display("Validate Ping Reply", Group: "Limits - Part B", Order: 5.5, Description: "Validate Ping Reply")]
        public PING_REPLY_VALIDATE PartBPingReplyValidate { get; set; }

        #endregion

        public V6LC_1_2_3_UnrecognizedNextHeader()
            : base()
        {
            // Show Validate options on GUI
            showValidateEchoRequest = true;
            showValidateEchoReply = false;

            // Validate options for this test
            validateEchoRequest = YesNo.Yes;
            validateEchoReply = YesNo.Yes;

            // Expected Test Case result
            PartAUnrecognizedNextHeaderValidate = UNRECOGNIZED_NEXT_HEADER_VALIDATE_REPLY.UNRECOGNIZED_NEXT_HEADER;
            PartAPingReplyValidate = PING_REPLY_VALIDATE.PING_REPLY;
            PartBUnrecognizedNextHeaderValidate = UNRECOGNIZED_NEXT_HEADER_VALIDATE_REPLY.UNRECOGNIZED_NEXT_HEADER;
            PartBPingReplyValidate = PING_REPLY_VALIDATE.NO_REPLY;

            FirstUnrecognizedHeader = 143;
            LastUnrecognizedHeader = 252;

            FormatStepName();
        }

        /// <summary>
        /// Procedure:
        /// 
        /// Part A: Unrecognized Next Header in Extension Header (Multiple Values)
        /// 1. TN1 transmits Packet A, which has a Destination Options header with a Next Header field of 143.
        /// 2. TN1 transmits a valid Echo Request to the NUT.
        /// 3. Repeat Steps 1 and 2 with all unrecognized Next Header values between 144 and 252 in Step 1.
        /// 4. Observe the Packets transmitted by the NUT.
        /// 
        /// Part B: Unexpected Next Header in Extension Header
        /// 5. TN1 transmits Packet B, which has a Destination Options header with a Next Header field of 60.
        /// The actual extension header that follows is a Fragment header. The Fragment Offset is 0x10E0
        /// (so that the first 8 bits of this 13 bit field would be 135). The second reserved field is 0x2 and the
        /// more bit is clear. (If processed as a Destination Options header, this would be processed as
        /// Option Data Length equals 4.)
        /// 6. Observe the Packets transmitted by the NUT.
        /// 
        /// Observable Results:
        /// • Part A
        /// Step 4: The NUT should send an ICMPv6 Parameter Problem message to TN1. The
        /// ICMPv6 Code field should be 1 (unrecognized Next Header type encountered). The ICMPv6
        /// Pointer field should be 0x28 (offset of the Next Header field). The NUT should send an Echo
        /// Reply in response to the Echo Request sent by TN1 in Step 2.
        /// • Part B
        /// Step 6: From the Next Header field in the Destination Options header, the NUT expects the
        /// Fragment header to be a Destination Options header. Thus, the Fragment Offset would be
        /// interpreted as if it were an Option Type. The NUT should send an ICMPv6 Parameter
        /// Problem message to TN1. The Code field should be 2 (unrecognized IPv6 Option
        /// encountered). The Pointer field should be 0x32 (offset of the Fragment Offset in the
        /// Fragment header). The NUT should discard Packet B and should not send an Echo Reply to
        /// TN1.
        /// </summary>
        public override void Run()
        {
            CommonTestInit();

            Verdict PingRequestReceivedStatus = Keysight.Tap.Verdict.NotSet;
            Verdict PingReplyReceivedStatus = Keysight.Tap.Verdict.NotSet;
            Verdict PingReplyReceivedStatus2 = Keysight.Tap.Verdict.NotSet;
            Verdict ParameterProblemStatus = Keysight.Tap.Verdict.NotSet;
            Verdict OverallStatus = Keysight.Tap.Verdict.Pass;

            // Retrieve the device list from the local machine
            IList<LivePacketDevice> allDevices = LivePacketDevice.AllLocalMachine;

            if (allDevices.Count == 0)
            {
                Log.Info("No interfaces found! Make sure WinPcap is installed.");
                return;
            }

            // Print the list
            for (int i = 0; i != allDevices.Count; ++i)
            {
                LivePacketDevice device = allDevices[i];
                Log.Info((i + 1) + ". " + device.Name);
                if (device.Description != null)
                    Log.Info(" (" + device.Description + ")");
                else
                    Log.Info(" (No description available)");
            }

            // Interface Index
            int deviceIndex = nicId;

            // Take the selected adapter
            PacketDevice selectedDevice = allDevices[deviceIndex - 1];

            // Open the output device
            using (PacketCommunicator communicator = selectedDevice.Open(100, // name of the device
                                                                         PacketDeviceOpenAttributes.Promiscuous, // promiscuous mode
                                                                         1000)) // read timeout
            {
                // ****************************************************************************
                // ***************************** PART A ***************************************
                // ****************************************************************************

                // Transmit Packet
                uintSequenceNumber++;
                byte bVer = (byte)Byte.Parse("6");
                byte bTrafficClass = 0;
                int nFlowLabel = 0;

                String TapFolder = System.IO.Path.GetDirectoryName(System.Windows.Forms.Application.ExecutablePath);
                String startTime = PlanRun.StartTime.ToString("yyyy-MM-dd-HH-mm-ss-");
                String logFileName = TapFolder + @"\Results\" + startTime + this.GetType().Name;
                // Start Packet Capture
                PcapCapturePackets packetCapture = new PcapCapturePackets(Log, nicId, sourceMAC, destinationMAC, sourceIPv6Address, dutIPv6Address, logFileName + "_PartA");
                // Make sure Packet Capture has started before sending ping request
                Thread.Sleep(1000);

                for (int nUnrecognizedNextHeader = FirstUnrecognizedHeader; nUnrecognizedNextHeader <= LastUnrecognizedHeader; nUnrecognizedNextHeader++)
                {
                    // Reset Packet counter
                    packetCapture.PacketCounter = 0;
                    packetCapture.LastPacket = null;
                    packetCapture.LastPacketParameterProblem = null;

                    // Packet A
                    communicator.SendPacket(NewBuildIpV6PacketGroup2UnrecognizedNextHeaderPacketA(uintIdentifier, uintSequenceNumber, bVer, bTrafficClass, nFlowLabel, "abcdefghijklmnopqrstuvwabcdefghi", (IpV4Protocol)nUnrecognizedNextHeader));

                    // Valid Ping request
                    communicator.SendPacket(NewBuildIpV6Packet(uintIdentifier, uintSequenceNumber, bVer, bTrafficClass, nFlowLabel, "abcdefghijklmnopqrstuvwabcdefghi", IpV4Protocol.InternetControlMessageProtocolForIpV6));

                    // Wait
                    Log.Info("Run()->Sleep");
                    int nRetry = 0;
                    do
                    {
                        // Wait until we have received echo and reply
                        Thread.Sleep(100);
                    } while ((packetCapture.PacketCounter < 4) && (nRetry++ < 10));

                    // Validate Received echo
                    Console.WriteLine("Packets Received: " + packetCapture.PacketCounter);

                    // Terminate capture packets
                    Packet lastPacket = packetCapture.LastPacket;
                    Packet lastPacketParameterProblem = packetCapture.LastPacketParameterProblem;
                    int nPacketCount = packetCapture.PacketCounter;
                    //packetCapture.StopPacketCapture();
                    //packetCapture = null;

                    // Validate Test Case
                    // Validate Echo reply was received
                    int nEchoReplyReceivedStatus = -1;
                    nEchoReplyReceivedStatus = ValidateEchoReceived(nPacketCount);
                    // Publish Results
                    Results.Publish("Main Results", new
                        List<string> { "Test Name", "LSL", "USL", "Measurement" },
                        new IConvertible[] { this.Name + "_Ping_Request_Received", 0, 1, nEchoReplyReceivedStatus });
                    PingRequestReceivedStatus = EvaluateResult(this.Name + "_Ping_Request_Received", 0, 1, nEchoReplyReceivedStatus);

                    // Validate ICMPv6 Parameter Problem
                    EvaluateParameterProblem(PartAUnrecognizedNextHeaderValidate, PingRequestReceivedStatus, nPacketCount, ref ParameterProblemStatus, lastPacketParameterProblem);

                    // Validate Ping Reply
                    EvaluatePingReply(PartAPingReplyValidate, PingRequestReceivedStatus, nPacketCount, ref PingReplyReceivedStatus, lastPacket);

                    // Update verdict to pass only if passed
                    if ((PingRequestReceivedStatus == Keysight.Tap.Verdict.Pass) &&
                        (PingReplyReceivedStatus == Keysight.Tap.Verdict.Pass) &&
                        (ParameterProblemStatus == Keysight.Tap.Verdict.Pass))
                    {

                    }
                    else
                    {
                        // Update status to fail if the test failed
                        OverallStatus = Keysight.Tap.Verdict.Fail;
                    }

                }

                // Test cleanup
                CommonTestCleanup(communicator, packetCapture);

                // ****************************************************************************
                // ***************************** PART B ***************************************
                // ****************************************************************************
                // NUT must transmit Receive Parameter Problem
                // NUT must discard echo request and not reply back
                // ****************************************************************************
                // Reset Packet counter
                Thread.Sleep(100);
                packetCapture = new PcapCapturePackets(Log, nicId, sourceMAC, destinationMAC, sourceIPv6Address, dutIPv6Address, logFileName + "_PartB");
                packetCapture.PacketCounter = 0;
                packetCapture.LastPacket = null;
                packetCapture.LastPacketParameterProblem = null;

                // Ping request
                communicator.SendPacket(NewBuildIpV6PacketGroup2UnrecognizedNextHeaderPacketB(uintIdentifier, uintSequenceNumber, bVer, bTrafficClass, nFlowLabel, "abcdefghijklmnopqrstuvwabcdefghi"));

                // Wait
                Log.Info("Run()->Sleep");
                int nRetry2 = 0;
                do
                {
                    // Wait until we have received echo and reply
                    Thread.Sleep(100);
                } while ((packetCapture.PacketCounter < 3) && (nRetry2++ < 40));

                // Validate Received echo
                Console.WriteLine("Packets Received: " + packetCapture.PacketCounter);

                // Terminate capture packets
                Packet lastPacket2 = packetCapture.LastPacket;
                Packet lastPacketParameterProblem2 = packetCapture.LastPacketParameterProblem;
                int nPacketCount2 = packetCapture.PacketCounter;
                //packetCapture.StopPacketCapture();
                //packetCapture = null;


                // Validate ICMPv6 Parameter Problem
                int nParameterProblemStatus2 = -1;
                switch (PartBUnrecognizedNextHeaderValidate)
                {
                    case UNRECOGNIZED_NEXT_HEADER_VALIDATE_REPLY.UNRECOGNIZED_NEXT_HEADER:
                        // if last packet is unrecognized next header
                        if ((PingRequestReceivedStatus == Keysight.Tap.Verdict.Pass) &&
                            (nPacketCount2 > 1))
                        {
                            nParameterProblemStatus2 = ValidateParameterProblemReceived(nPacketCount2, lastPacketParameterProblem2);
                            // Publish Results
                            Results.Publish("Main Results", new
                                List<string> { "Test Name", "LSL", "USL", "Measurement" },
                                new IConvertible[] { this.Name + "_ParameterProblemStatus_Received", 0, 1, nParameterProblemStatus2 });
                            ParameterProblemStatus = EvaluateResult(this.Name + "_ParameterProblemStatus_Received", 0, 1, nParameterProblemStatus2);
                        }
                        else
                        {
                            nParameterProblemStatus2 = -11;
                            // Publish Results
                            Results.Publish("Main Results", new
                                List<string> { "Test Name", "LSL", "USL", "Measurement" },
                                new IConvertible[] { this.Name + "_ParameterProblemStatus_Received", 0, 1, nParameterProblemStatus2 });
                            ParameterProblemStatus = EvaluateResult(this.Name + "_ParameterProblemStatus_Received", 0, 1, nParameterProblemStatus2);
                        }
                        break;
                    case UNRECOGNIZED_NEXT_HEADER_VALIDATE_REPLY.NO_REPLY:
                        // Validate lastPacketParameterProblem is null
                        // this means that the pcap library didn't find any parameter problem packets
                        if (lastPacketParameterProblem2 == null)
                        {
                            // PASS
                            nParameterProblemStatus2 = 0;
                            // Publish Results
                            Results.Publish("Main Results", new
                                List<string> { "Test Name", "LSL", "USL", "Measurement" },
                                new IConvertible[] { this.Name + "_ParameterProblemStatus_Received", 0, 1, nParameterProblemStatus2 });
                            ParameterProblemStatus = EvaluateResult(this.Name + "_ParameterProblemStatus_Received", 0, 1, nParameterProblemStatus2);
                        }
                        else
                        {
                            // FAil
                            nParameterProblemStatus2 = -12;
                            // Publish Results
                            Results.Publish("Main Results", new
                                List<string> { "Test Name", "LSL", "USL", "Measurement" },
                                new IConvertible[] { this.Name + "_ParameterProblemStatus_Received", 0, 1, nParameterProblemStatus2 });
                            ParameterProblemStatus = EvaluateResult(this.Name + "_ParameterProblemStatus_Received", 0, 1, nParameterProblemStatus2);
                        }
                        break;
                }

                // Validate Ping Reply

                //int nPingReplyReceivedStatus2 = -1;
                EvaluatePingReply(PartBPingReplyValidate, Keysight.Tap.Verdict.Pass, nPacketCount2, ref PingReplyReceivedStatus2, lastPacket2);
                //switch (PartBPingReplyValidate)
                //{
                //    case PING_REPLY_VALIDATE.PING_REPLY:
                //        // if last packet is ping reply
                //        if ((PingRequestReceivedStatus == Keysight.Tap.Verdict.Pass) &&
                //            (nPacketCount2 > 1))
                //        {
                //            nPingReplyReceivedStatus2 = ValidatePingReplyReceived(nPacketCount2, lastPacket2);
                //            // Publish Results
                //            Results.Publish("Main Results", new
                //                List<string> { "Test Name", "LSL", "USL", "Measurement" },
                //                new IConvertible[] { this.Name + "nPingReplyReceivedStatus", 0, 1, nPingReplyReceivedStatus2 });
                //            PingReplyReceivedStatus = EvaluateResult(this.Name + "nPingReplyReceivedStatus", 0, 1, nPingReplyReceivedStatus2);
                //        }
                //        else
                //        {
                //            nPingReplyReceivedStatus2 = -12;
                //            // Publish Results
                //            Results.Publish("Main Results", new
                //                List<string> { "Test Name", "LSL", "USL", "Measurement" },
                //                new IConvertible[] { this.Name + "nPingReplyReceivedStatus", 0, 1, nPingReplyReceivedStatus2 });
                //            PingReplyReceivedStatus = EvaluateResult(this.Name + "nPingReplyReceivedStatus", 0, 1, nPingReplyReceivedStatus2);
                //        }
                //        break;
                //    case PING_REPLY_VALIDATE.NO_REPLY:
                //        if ((PingRequestReceivedStatus == Keysight.Tap.Verdict.Pass) &&
                //            (nPacketCount2 <= 1))
                //        {
                //            nPingReplyReceivedStatus2 = 0;
                //            // Publish Results
                //            Results.Publish("Main Results", new
                //                List<string> { "Test Name", "LSL", "USL", "Measurement" },
                //                new IConvertible[] { this.Name + "NoReply", 0, 1, nPingReplyReceivedStatus2 });
                //            PingReplyReceivedStatus = EvaluateResult(this.Name + "NoReply", 0, 1, nPingReplyReceivedStatus2);
                //        }
                //        else
                //        {
                //            nPingReplyReceivedStatus2 = -10;
                //            // Publish Results
                //            Results.Publish("Main Results", new
                //                List<string> { "Test Name", "LSL", "USL", "Measurement" },
                //                new IConvertible[] { this.Name + "NoReply", 0, 1, nPingReplyReceivedStatus2 });
                //            PingReplyReceivedStatus = EvaluateResult(this.Name + "NoReply", 0, 1, nPingReplyReceivedStatus2);
                //        }
                //        break;
                //}

                // Update verdict to pass only if passed
                if ((PingRequestReceivedStatus == Keysight.Tap.Verdict.Pass) &&
                    (PingReplyReceivedStatus == Keysight.Tap.Verdict.Pass) &&
                    (PingReplyReceivedStatus2 == Keysight.Tap.Verdict.Pass) &&
                    (ParameterProblemStatus == Keysight.Tap.Verdict.Pass))
                {

                }
                else
                {
                    // Update status to fail if the test failed
                    OverallStatus = Keysight.Tap.Verdict.Fail;
                }

                // Test cleanup
                CommonTestCleanup(communicator, packetCapture);
            }

            // Update verdict to pass only if PER and RSSI have passed
            if (OverallStatus == Keysight.Tap.Verdict.Pass)
            {
                UpgradeVerdict(Verdict.Pass);
            }
            else
            {
                UpgradeVerdict(Verdict.Fail);
            }
        }

    }
}
